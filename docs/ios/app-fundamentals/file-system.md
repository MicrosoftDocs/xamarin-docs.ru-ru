---
title: Доступ к файловой системе в Xamarin. iOS
description: В этом документе описывается работа с файловой системой в Xamarin. iOS. Здесь обсуждаются каталоги, чтение файлов, сериализация XML и JSON, изолированная среда приложения, предоставление общего доступа к файлам через iTunes и многое другое.
ms.prod: xamarin
ms.assetid: 37DF2F38-901E-8F8E-269A-5EE0CCD28C08
ms.technology: xamarin-ios
author: davidortinau
ms.author: daortin
ms.date: 11/12/2018
ms.openlocfilehash: ffb49329b38705d097520b24d53285d5dbf15167
ms.sourcegitcommit: ebdc016b3ec0b06915170d0cbbd9e0e2469763b9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/05/2020
ms.locfileid: "93371811"
---
# <a name="file-system-access-in-xamarinios"></a>Доступ к файловой системе в Xamarin. iOS

[![Загрузить образец](~/media/shared/download.png) загрузить пример](/samples/xamarin/ios-samples/filesystemsamplecode)

`System.IO`Для доступа к файловой системе iOS можно использовать Xamarin. iOS и классы в *библиотеке базовых классов (BCL) .NET* . Класс `File` позволяет создавать, удалять и считывать файлы, а класс и `Directory` — создавать, удалять или перечислять содержимое каталогов. Кроме того, можно использовать `Stream` подклассы, которые обеспечивают большую степень контроля над операциями с файлами (например, сжатие или поиск по положению в файле).

iOS накладывает некоторые ограничения на то, что может делать приложение с файловой системой для сохранения безопасности данных приложения, а также для защиты пользователей от малигнант приложений. Эти ограничения являются частью *песочницы приложения* — набора правил, ограничивающих доступ приложения к файлам, предпочтениям, сетевым ресурсам, оборудованию и т. д. Приложение ограничено чтением и записью файлов в своем домашнем каталоге (установленном расположении); Он не может получить доступ к файлам другого приложения.

в iOS также есть некоторые специальные функции, связанные с файловой системой. для определенных каталогов требуется особая обработка при резервном копировании и обновлении. Кроме того, приложения могут обмениваться файлами друг с другом, а также с приложением " **файлы** " (начиная с iOS 11) и через iTunes.

В этой статье обсуждаются функции и ограничения файловой системы iOS, а также пример приложения, демонстрирующий использование Xamarin. iOS для выполнения некоторых простых операций файловой системы.

[![Пример iOS, в котором выполняются некоторые простые операции файловой системы](file-system-images/01-sampleapp-sml.png)](file-system-images/01-sampleapp.png#lightbox)

## <a name="general-file-access"></a>Общий доступ к файлам

Xamarin. iOS позволяет использовать `System.IO` классы .NET для операций файловой системы в iOS.

В следующих фрагментах кода показаны некоторые распространенные операции с файлами. Их можно найти ниже в файле **SampleCode.CS** в примере приложения для этой статьи.

### <a name="working-with-directories"></a>Работа с каталогами

Этот код перечисляет подкаталоги в текущем каталоге (задается параметром "./"), который является расположением исполняемого файла приложения.
Выходные данные будут представлять собой список всех файлов и папок, развернутых вместе с приложением (отображается в окне консоли во время отладки).

```csharp
var directories = Directory.EnumerateDirectories("./");
foreach (var directory in directories) {
      Console.WriteLine(directory);
}
```

### <a name="reading-files"></a>Чтение файлов

Для чтения текстового файла требуется всего одна строка кода. В этом примере содержимое текстового файла будет отображаться в окне вывод приложения.

```csharp
var text = File.ReadAllText("TestData/ReadMe.txt");
Console.WriteLine(text);
```

### <a name="xml-serialization"></a>сериализация XML

Несмотря на то, что работа с полным `System.Xml` пространством имен выходит за рамки этой статьи, можно легко десериализовать XML-документ из файловой системы с помощью StreamReader, подобного этому фрагменту кода:

```csharp
using (TextReader reader = new StreamReader("./TestData/test.xml")) {
      XmlSerializer serializer = new XmlSerializer(typeof(MyObject));
      var xml = (MyObject)serializer.Deserialize(reader);
}
```

Дополнительные сведения см. в документации по [System.Xml](xref:System.Xml) и [сериализации](xref:System.Xml.Serialization). См. [документацию по Xamarin. iOS](~/ios/deploy-test/linker.md) в компоновщике — часто требуется добавить `[Preserve]` атрибут к классам, которые предполагается сериализовать.

### <a name="creating-files-and-directories"></a>Создание файлов и каталогов

В этом примере показано, как использовать `Environment` класс для доступа к папке «документы», в которой можно создавать файлы и каталоги.

```csharp
var documents =
 Environment.GetFolderPath (Environment.SpecialFolder.MyDocuments); 
var filename = Path.Combine (documents, "Write.txt");
File.WriteAllText(filename, "Write this text into a file");
```

Процесс создания каталога аналогичен:

```csharp
var documents =
 Environment.GetFolderPath (Environment.SpecialFolder.MyDocuments);
var directoryname = Path.Combine (documents, "NewDirectory");
Directory.CreateDirectory(directoryname);
```

Дополнительные сведения см. в [справочнике по API System.IO](xref:System.IO).

### <a name="serializing-json"></a>Сериализация JSON

[JSON.NET](http://www.newtonsoft.com/json) — это высокопроизводительная платформа JSON, которая работает с Xamarin. iOS и доступна в NuGet. Добавьте пакет NuGet в проект приложения с помощью команды **Добавить NuGet** в Visual Studio для Mac:

[![Добавление пакета NuGet в проект приложений](file-system-images/json01.png)](file-system-images/json01.png#lightbox)

Затем добавьте класс, который будет использоваться в качестве модели данных для сериализации или десериализации (в данном случае `Account.cs` ):

```csharp
using System;
using System.Collections.Generic;
using Foundation; // for Preserve attribute, which helps serialization with Linking enabled

namespace FileSystem
{
    [Preserve]
    public class Account
    {
        public string Email { get; set; }
        public bool Active { get; set; }
        public DateTime CreatedDate { get; set; }
        public List<string> Roles { get; set; }

        public Account() {
        }
    }
}
```

Наконец, создайте экземпляр `Account` класса, выполните его сериализацию в данные JSON и запишите в файл:

```csharp
// Create a new record
var account = new Account(){
    Email = "monkey@xamarin.com",
    Active = true,
    CreatedDate = new DateTime(2015, 5, 27, 0, 0, 0, DateTimeKind.Utc),
    Roles = new List<string> {"User", "Admin"}
};

// Serialize object
var json = JsonConvert.SerializeObject(account, Newtonsoft.Json.Formatting.Indented);

// Save to file
var documents = Environment.GetFolderPath (Environment.SpecialFolder.MyDocuments);
var filename = Path.Combine (documents, "account.json");
File.WriteAllText(filename, json);
```

Дополнительные сведения о работе с данными JSON в приложении .NET см. в [документации по](https://www.newtonsoft.com/json/help)JSON. NET.

## <a name="special-considerations"></a>Специальные рекомендации

Несмотря на сходство между Xamarin. iOS и файловыми операциями .NET, iOS и Xamarin. iOS отличаются от .NET одним из важных способов.

### <a name="making-project-files-accessible-at-runtime"></a>Предоставление доступа к файлам проекта во время выполнения

По умолчанию, если добавить файл в проект, он не будет включаться в окончательную сборку и, следовательно, будет недоступен для приложения. Чтобы включить файл в сборку, необходимо пометить его специальным действием сборки, которое называется Content.

Чтобы пометить файл для включения, щелкните правой кнопкой мыши файл (ы) и выберите пункт **действие сборки &gt; содержимое** в Visual Studio для Mac. Также можно изменить **действие сборки** на странице **свойств** файла.

### <a name="case-sensitivity"></a>Чувствительность к регистру

Важно понимать, что в файловой системе iOS *учитывается регистр*. Чувствительность к регистру означает, что имена файлов и каталогов должны точно совпадать — **README.txt** и **readme.txt** будут считаться разными именами файлов.

Это может быть запутанным для разработчиков .NET, знакомых с файловой системой Windows, которые не *чувствительны к регистру* — **файлы** , **файлы** и **файлы** будут ссылаться на один и тот же каталог.

> [!WARNING]
> В симуляторе iOS не учитывается регистр.
> Если регистр имен файлов отличается между самим файлом и ссылками на него в коде, код может по-прежнему работать в симуляторе, но на реальном устройстве произойдет сбой. Это одна из причин того, почему важно выполнить развертывание и тестирование на фактическом устройстве на ранней стадии и часто во время разработки iOS.

### <a name="path-separator"></a>Разделитель пути

в iOS используется символ косой черты "/" в качестве разделителя пути (который отличается от Windows, в котором используется обратная косая черта "\").

Из-за такого затруднения рекомендуется использовать `System.IO.Path.Combine` метод, который корректирует текущую платформу вместо жестко определенного разделителя пути. Это простой шаг, который делает ваш код более переносимым на другие платформы.

## <a name="application-sandbox"></a>Изолированная среда приложения

Доступ приложения к файловой системе (и другим ресурсам, таким как сетевые и аппаратные компоненты) ограничен по соображениям безопасности. Это ограничение называется *песочницей приложения*. С точки зрения файловой системы приложение ограничено созданием и удалением файлов и каталогов в домашнем каталоге.

Корневой каталог — это уникальное расположение в файловой системе, где хранятся приложение и все его данные. Нельзя выбрать (или изменить) расположение домашнего каталога для приложения. Однако iOS и Xamarin. iOS предоставляют свойства и методы для управления файлами и каталогами внутри.

## <a name="the-application-bundle"></a>Набор приложений

*Набор приложений* — это папка, в которой находится приложение.
Оно отличается от других папок путем добавления суффикса. app к имени каталога. Пакет приложений содержит исполняемый файл и все содержимое (файлы, изображения и т. д.), необходимые для проекта.

При переходе к набору приложений в Mac OS отображается значок, отличный от значка в других каталогах (и суффикс **приложения** скрыт). Однако это просто обычный каталог, который операционная система отображает по-разному.

Чтобы просмотреть набор приложений для примера кода, щелкните правой кнопкой мыши проект в **Visual Studio для Mac** и выберите пункт **Показать в Finder**. Затем перейдите в папку **bin/** каталог, где следует найти значок приложения (как показано на снимке экрана ниже).

![Перейдите в каталог bin, чтобы найти значок приложения, как на снимке экрана](file-system-images/40-bundle.png)

Щелкните этот значок правой кнопкой мыши и выберите команду " **отобразить содержимое пакета** ", чтобы просмотреть содержимое каталога пакета приложений. Содержимое выглядит так же, как содержимое обычного каталога, как показано ниже:

[![Содержимое набора приложений](file-system-images/45-bundle-sml.png)](file-system-images/45-bundle.png#lightbox)

Набор приложений — это то, что устанавливается в симуляторе или на устройстве во время тестирования, и в конечном итоге отправляется в Apple для включения в магазин приложений.

## <a name="application-directories"></a>Каталоги приложений

При установке приложения на устройстве операционная система создает домашний каталог для приложения и создает несколько каталогов в корневом каталоге приложения, которые доступны для использования. Начиная с iOS 8, доступные пользователям каталоги [не размещаются](https://developer.apple.com/library/ios/technotes/tn2406/_index.html) в корневом каталоге приложения, поэтому нельзя наследовать пути к набору приложений из пользовательских каталогов или наоборот.

Эти каталоги, определение пути и их назначение перечислены ниже.

&nbsp;

|Каталог|Описание|
|---|---|
|[ИмяПриложения]. app/|**В iOS 7 и более ранних версий** это `ApplicationBundle` каталог, в котором хранится исполняемый файл приложения. Структура каталогов, созданная в приложении, существует в этом каталоге (например, изображения и другие типы файлов, помеченные как ресурсы в проекте Visual Studio для Mac).<br /><br />Если необходимо получить доступ к файлам содержимого в пакете приложений, путь к этому каталогу будет доступен через `NSBundle.MainBundle.BundlePath` свойство.|
|Документаци|Используйте этот каталог для хранения пользовательских документов и файлов данных приложений.<br /><br />Содержимое этого каталога можно сделать доступным для пользователя с помощью общего доступа к файлам iTunes (хотя по умолчанию этот параметр отключен). Добавьте `UIFileSharingEnabled` логический ключ в файл info. plist, чтобы разрешить пользователям доступ к этим файлам.<br /><br />Даже если приложение сразу же не включает общий доступ к файлам, следует избегать размещения файлов, которые должны быть скрыты от пользователей в этом каталоге (например, файлы базы данных, если вы не собираетесь поделиться ими). При условии, что конфиденциальные файлы остаются скрытыми, эти файлы не будут предоставлены (и потенциально перемещены, изменены или удалены iTunes), если в будущей версии включен общий доступ к файлам.<br /><br /> С помощью метода можно `Environment.GetFolderPath (Environment.SpecialFolder.MyDocuments)` получить путь к каталогу документов для приложения.<br /><br />Содержимое этого каталога архивируется в iTunes.|
|Библиотечная|Каталог библиотеки является хорошим местом для хранения файлов, которые не создаются непосредственно пользователем, например баз данных или других файлов, созданных приложением. Содержимое этого каталога никогда не предоставляется пользователю через iTunes.<br /><br />В библиотеке можно создавать собственные подкаталоги. Однако уже есть некоторые созданные системой каталоги, о которых следует знать, включая настройки и кэши.<br /><br />Содержимое этого каталога (за исключением подкаталога кэшей) архивируется программой iTunes. Создается резервная копия пользовательских каталогов, создаваемых в библиотеке.|
|Библиотека/настройки/|Файлы предпочтений, относящиеся к приложению, хранятся в этом каталоге. Не создавайте эти файлы напрямую. Вместо этого используйте `NSUserDefaults` класс.<br /><br />Содержимое этого каталога архивируется в iTunes.|
|Библиотеки/кэши/|Каталог кэшей — это хорошее место для хранения файлов данных, которые могут помочь в выполнении приложения, но их можно легко создать повторно. Приложение должно создавать и удалять эти файлы по мере необходимости и иметь возможность повторно создавать эти файлы при необходимости. iOS 5 также может удалить эти файлы (в ситуациях, в которых возникают проблемы с хранилищем), однако это не будет делаться во время работы приложения.<br /><br />Содержимое этого каталога не архивируется в iTunes. Это означает, что они не будут включены, если пользователь восстановит устройство, и они могут отсутствовать после установки обновленной версии приложения.<br /><br />Например, если приложение не может подключиться к сети, вы можете использовать каталог кэшей для хранения данных или файлов, чтобы обеспечить хорошую работу в автономном режиме. Приложение может быстро сохранять и получать эти данные, ожидая сетевых ответов, но не нуждается в резервном копировании и легко восстанавливать или повторно создавать после обновления или восстановления версии.|
|TMP|Приложения могут хранить временные файлы, которые требуются только в течение короткого периода в этом каталоге. Чтобы сэкономить место, следует удалить файлы, если они больше не требуются. Операционная система также может удалять файлы из этого каталога, если приложение не работает.<br /><br />Содержимое этого каталога не архивируется программой iTunes.<br /><br />Например, каталог tmp может использоваться для хранения временных файлов, которые будут загружены для отображения пользователю (например, аватары Twitter или вложения электронной почты), но их можно удалить после просмотра (и скачать снова, если они нужны в будущем).|

На этом снимке экрана показана структура каталогов в окне поиска:

[![На этом снимке экрана показана структура каталогов в окне Finder](file-system-images/08-library-directory.png)](file-system-images/08-library-directory.png#lightbox)

### <a name="accessing-other-directories-programmatically"></a>Программный доступ к другим каталогам

В предыдущих примерах каталогов и файлов использовался доступ к `Documents` каталогу. Для записи в другой каталог необходимо создать путь с помощью синтаксиса "..", как показано ниже:

```csharp
var documents = Environment.GetFolderPath (Environment.SpecialFolder.MyDocuments);
var library = Path.Combine (documents, "..", "Library");
var filename = Path.Combine (library, "WriteToLibrary.txt");
File.WriteAllText(filename, "Write this text into a file in Library");
```

Создание каталога похоже на:

```csharp
var documents = Environment.GetFolderPath (Environment.SpecialFolder.MyDocuments);
var library = Path.Combine (documents, "..", "Library");
var directoryname = Path.Combine (library, "NewLibraryDirectory");
Directory.CreateDirectory(directoryname);
```

Пути к `Caches` `tmp` каталогам и могут быть созданы следующим образом:

```csharp
var documents = Environment.GetFolderPath (Environment.SpecialFolder.MyDocuments);
var cache = Path.Combine (documents, "..", "Library", "Caches");
var tmp = Path.Combine (documents, "..", "tmp");
```

## <a name="sharing-with-the-files-app"></a>Совместное использование с приложением "файлы"

в iOS 11 введено приложение " **файлы** " — Обозреватель файлов для iOS, позволяющий пользователю видеть свои файлы и взаимодействовать с ними в iCloud, а также храниться в любом приложении, которое его поддерживает. Чтобы разрешить пользователю прямой доступ к файлам в приложении, создайте новый логический ключ в файле **info. plist** `LSSupportsOpeningDocumentsInPlace` и задайте для него значение `true` , как показано ниже:

![Set Лссуппортсопенингдокументсинплаце в info. plist](file-system-images/51-supports-opening.png)

Каталог **документов** приложения теперь будет доступен для обзора в приложении " **файлы** ". В приложении " **файлы** " перейдите на **мой iPhone** , и все приложения с общими файлами будут видны. На снимках экрана ниже показано, как выглядит [пример приложения FileSystem](/samples/xamarin/ios-samples/filesystemsamplecode) :

![приложение iOS 11 Files](file-system-images/50-files-app-1-sml.png) ![Просмотр моих файлов iPhone](file-system-images/50-files-app-2-sml.png) ![Файлы примеров приложений](file-system-images/50-files-app-3-sml.png)

## <a name="sharing-files-with-the-user-through-itunes"></a>Совместное использование файлов с пользователем через iTunes

Пользователи могут получить доступ к файлам в каталоге документов приложения, отредактировав `Info.plist` и создав **приложение, которое поддерживает** `UIFileSharingEnabled` запись в представлении **исходного кода** в формате iTunes (), как показано ниже:

[![Добавление приложения поддерживает свойство "совместное использование iTunes"](file-system-images/09-uifilesharingenabled-plist-sml.png)](file-system-images/09-uifilesharingenabled-plist.png#lightbox)

Доступ к этим файлам можно получить в iTunes, когда устройство подключено, и пользователь выбрал `Apps` вкладку. Например, на следующем снимке экрана показаны файлы в выбранном приложении, совместно используемые в iTunes:

[![На этом снимке экрана показаны файлы в выбранном приложении, общие через iTunes](file-system-images/10-itunes-file-sharing-sml.png)](file-system-images/10-itunes-file-sharing.png#lightbox)

Пользователи могут получать доступ только к элементам верхнего уровня в этом каталоге через iTunes. Они не видят содержимое подкаталогов (хотя они могут скопировать их на свой компьютер или удалить). Например, файлы Гудреадер, PDF и ЕПУБ можно совместно использовать с приложением, чтобы пользователи могли читать их на своих устройствах iOS.

Пользователи, которые изменяют содержимое папки «документы», могут вызвать проблемы, если это не так осторожно. Приложение должно принимать это в виду и быть устойчивым к разрушенным обновлениям папки «документы».

В примере кода для этой статьи создается файл и папка в папке Documents (в **SampleCode.CS** ), а также включается общий доступ к файлам в файле **info. plist** . На этом снимке экрана показано, как они отображаются в iTunes:

[![На этом снимке экрана показано, как файлы отображаются в iTunes](file-system-images/15-itunes-file-sharing-example-sml.png)](file-system-images/15-itunes-file-sharing-example.png#lightbox)

Сведения о настройке значков для приложения и пользовательских типов документов см. в статье [Работа с изображениями](~/ios/app-fundamentals/images-icons/index.md) .

Если `UIFileSharingEnabled` ключ имеет значение false или отсутствует, то общий доступ к файлам по умолчанию отключен, и пользователи не смогут взаимодействовать с каталогом документов.

## <a name="backup-and-restore"></a>Резервное копирование и восстановление

При резервном копировании устройства программой iTunes все каталоги, созданные в домашнем каталоге приложения, будут сохранены, за исключением следующих каталогов:

- **[ApplicationName]. app** — не записывать в этот каталог, так как он подписан и поэтому должен остаться без изменений после установки. Он может содержать ресурсы, к которым вы обращаетесь из кода, но не требуется резервное копирование, так как они будут восстановлены путем повторной загрузки приложения.
- **Библиотеки и кэши** — каталог кэша предназначен для рабочих файлов, которые не нуждаются в резервном копировании.
- **tmp** — этот каталог используется для временных файлов, которые создаются и удаляются, когда они больше не нужны, или для файлов, удаляемых iOS, когда требуется место.

Создание резервной копии большого объема данных может занять длительное время. Если вы решили создать резервную копию конкретного документа или данных, в приложении следует использовать папки Documents и Library. Для временных данных или файлов, которые можно легко получить из сети, используйте кэши или каталог tmp.

> [!NOTE]
> iOS выполнит очистку файловой системы, когда на устройстве не хватает места на диске.
> Этот процесс приведет к удалению всех файлов из библиотеки, кэшей и папки tmp приложений, которые в данный момент не выполняются.

## <a name="complying-with-ios-5-icloud-backup-restrictions"></a>Соблюдение ограничений резервного копирования с помощью iOS 5

> [!NOTE]
> Хотя эта политика впервые появилась в iOS 5 (что кажется довольно давно), руководство по-прежнему относится к приложениям уже сегодня.

Компания Apple представила функцию *резервного копирования iCloud* с iOS 5. Если резервное копирование iCloud включено, все файлы в домашнем каталоге приложения (за исключением каталогов, которые обычно не архивируются, например, набор приложений, `Caches` и `tmp` ) архивируются на серверы iCloud. Эта функция предоставляет пользователю полную резервную копию на случай утери, кражи или повреждения устройства.

Так как в iCloud предоставляется только 5 ГБ свободного пространства для каждого пользователя, и во избежание необязательного использования пропускной способности компания Apple представит приложениям создавать резервные копии только необходимых пользовательских данных. Чтобы соответствовать рекомендациям по хранению данных iOS, необходимо ограничить объем данных, резервное копирование которых будет выполняться, применив следующие элементы:

- Храните данные, созданные пользователем, или данные, которые не могут быть повторно созданы, в каталоге документов (резервная копия).
- Храните любые другие данные, которые можно легко создать или повторно скачать в `Library/Caches` или `tmp` (который не архивируется и может быть очищен).
- Если у вас есть файлы, которые могут быть подходящими для `Library/Caches` папки или, `tmp` но вы не хотите очищать их, сохраните их в любом месте (например, `Library/YourData` ) и примените атрибут "не создавать резервные копии", чтобы файлы не могли использовать пропускную способность резервного копирования iCloud и пространство для хранения. Эти данные по-прежнему используют пространство на устройстве, поэтому следует внимательно управлять им и удалять его по возможности.

Атрибут "не выполнять резервное копирование" задается с помощью `NSFileManager` класса. Убедитесь, что ваш класс `using Foundation` и вызывает `SetSkipBackupAttribute` его следующим образом:

```csharp
var documents = Environment.GetFolderPath (Environment.SpecialFolder.MyDocuments);
var filename = Path.Combine (documents, "LocalOnly.txt");
File.WriteAllText(filename, "This file will never get backed-up. It would need to be re-created after a restore or re-install");
NSFileManager.SetSkipBackupAttribute (filename, true); // backup will be skipped for this file
```

Если `SetSkipBackupAttribute` `true` файл не будет архивироваться, независимо от каталога, в котором он хранится (даже в `Documents` каталоге). Вы можете запросить атрибут с помощью `GetSkipBackupAttribute` метода, а затем сбросить его, вызвав `SetSkipBackupAttribute` метод с следующим `false` образом:

```csharp
NSFileManager.SetSkipBackupAttribute (filename, false); // file will be backed-up
```

## <a name="sharing-data-between-ios-apps-and-app-extensions"></a>Совместное использование данных между приложениями iOS и расширениями приложений

Так как расширения приложений выполняются как часть ведущего приложения (в отличие от их приложения), общий доступ к данным не включается автоматически, поэтому требуется дополнительный объем работы. Группы приложений — это механизм, используемый iOS для предоставления различным приложениям общего доступа к данным. Если приложения были правильно настроены с использованием правильных прав и подготовки, они смогут получить доступ к общему каталогу за пределами обычной песочницы iOS.

### <a name="configure-an-app-group"></a>Настройка группы приложений

Общее расположение настраивается с помощью [группы приложений](https://developer.apple.com/library/archive/documentation/Miscellaneous/Reference/EntitlementKeyReference/Chapters/EnablingAppSandbox.html#//apple_ref/doc/uid/TP40011195-CH4-SW19), которая настроена в разделе **сертификаты, идентификаторы & профилей** в [центре разработки iOS](https://developer.apple.com/devcenter/ios/). Это значение также должно быть задано в списке прав каждого проекта **. plist**.

Сведения о создании и настройке группы приложений см. в руководстве по [возможностям группы приложений](~/ios/deploy-test/provisioning/capabilities/app-groups-capabilities.md) .

### <a name="files"></a>Файлы

Приложение iOS и расширение также могут предоставлять общий доступ к файлам с помощью общего пути к файлу (при наличии правильно настроенных разрешений и подготовки):

```csharp
var FileManager = new NSFileManager ();
var appGroupContainer =FileManager.GetContainerUrl ("group.com.xamarin.WatchSettings");
var appGroupContainerPath = appGroupContainer.Path

Console.WriteLine ("Group Path: " + appGroupContainerPath);

// use the path to create and update files
...
```

> [!IMPORTANT]
> Если возвращенный путь к группе имеет значение `null` , проверьте конфигурацию прав и профиль подготовки и убедитесь, что они верны.

## <a name="application-version-updates"></a>Обновления версии приложения

При скачивании новой версии приложения iOS создает новый корневой каталог и сохраняет в нем новый набор приложений. затем iOS перемещает следующие папки из предыдущей версии пакета приложений в новый домашний каталог:

- **Документы**
- **Библиотека**

Другие каталоги также могут быть скопированы и размещены в новом домашнем каталоге, но их копирование не гарантируется, поэтому ваше приложение не должно полагаться на это поведение системы.

## <a name="summary"></a>Сводка

В этой статье показано, что операции файловой системы с Xamarin. iOS похожи на любые другие приложения .NET. В нем также появилась изолированная среда приложения и рассмотрены последствия безопасности, которые она вызывает. Затем мы изучили концепцию пакета приложений. Наконец, он перечисляет специализированные каталоги, доступные для приложения, и поясняет их роли во время обновления и резервного копирования приложения.

## <a name="related-links"></a>Связанные ссылки

- [Пример кода FileSystem](/samples/xamarin/ios-samples/filesystemsamplecode)
- [Инструкции по программированию файловой системы](https://developer.apple.com/library/ios/#documentation/FileManagement/Conceptual/FileSystemProgrammingGUide/Introduction/Introduction.html)
- [Регистрация типов файлов, поддерживаемых приложением](https://developer.apple.com/library/ios/#documentation/FileManagement/Conceptual/DocumentInteraction_TopicsForIOS/Articles/RegisteringtheFileTypesYourAppSupports.html#/apple_ref/doc/uid/TP40010411-SW1)