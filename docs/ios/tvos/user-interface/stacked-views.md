---
title: Работа с tvOSными представлениями с накоплением в Xamarin
description: В этом документе описывается, как работать с tvOSными представлениями с накоплением в приложении, созданном с помощью Xamarin. Он предоставляет общий обзор представлений с накоплением и обсуждает автоматическое размещение, размещение и определение размеров для представления с накоплением, общее использование, интеграцию с раскадровками и многое другое.
ms.prod: xamarin
ms.assetid: 00B07F85-F30B-4DD4-8664-A61D0A1CDB0E
ms.technology: xamarin-ios
author: davidortinau
ms.author: daortin
ms.date: 03/16/2017
ms.openlocfilehash: 1d6f2b6cbc18317562396308bf353c83a8471c2c
ms.sourcegitcommit: 4bbf54d2bc1df96af69814e2e5dae47be12e0474
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/10/2021
ms.locfileid: "102602896"
---
# <a name="working-with-tvos-stacked-views-in-xamarin"></a>Работа с tvOSными представлениями с накоплением в Xamarin
> [!WARNING]
> Конструктор iOS устарел в Visual Studio 2019 версии 16,8 и Visual Studio 2019 для Mac версии 8,8 и удален в Visual Studio 2019 версии 16,9 и Visual Studio для Mac версии 8,9.
> Рекомендуемый способ создания пользовательских интерфейсов iOS — непосредственно на компьютере Mac с Interface Builder. Дополнительные сведения см. в разделе [Разработка пользовательских интерфейсов с помощью Xcode](~/ios/user-interface/storyboards/index.md). 

Элемент управления "представление стека" ( `UIStackView` ) использует возможности классов автоматического макета и размера для управления стеком подпросмотров (горизонтально или вертикально), который динамически реагирует на изменения содержимого и размер экрана устройства Apple TV.

Макет всех вложенных представлений, присоединенных к представлению «стек», управляется на основе свойств, определенных разработчиком, таких как ось, распределение, выравнивание и отступы:

[![Диаграмма макета подпредставления](stacked-views-images/stacked01.png)](stacked-views-images/stacked01.png#lightbox)

При использовании `UIStackView` в приложении Xamarin. tvOS разработчик может либо определять вложенные представления в раскадровке в конструкторе iOS, либо добавлять и удалять подпредставления в коде C#.

## <a name="about-stacked-view-controls"></a>Сведения об элементах управления "представление с накоплением"

`UIStackView`Класс предназначен для неотрисовки представления контейнера и поэтому не отображается на холсте, как и другие подклассы `UIView` . Установка таких свойств, как `BackgroundColor` или переопределение, не `DrawRect` будет иметь визуального влияния.

Существует несколько свойств, которые управляют тем, как представление Stack будет упорядочивать коллекцию вложенных представлений:

- **Axis** — определяет, будет ли представление стека упорядочивать подпредставления **горизонтально** или **вертикально**.
- **Выравнивание** — управляет выравниванием вложенных представлений в представлении стека.
- **Распространение** — управляет изменением размера вложенных представлений в представлении стека.
- **Пробел** — управляет минимальным пространством между каждым подпредставлением в представлении Stack.
- **Относительное выравнивание по базовому плану** — если по `true` вертикали в каждом подпредставлении будет получен производный междустрочный пробел.
- **Поля макета относительные** — размещает подпредставления относительно стандартных полей макета.

Как правило, для размещения небольшого числа подпросмотров используется представление Stack. Более сложные пользовательские интерфейсы могут быть созданы путем вложения одного или нескольких представлений стеков друг в друга.

Можно настроить внешний вид пользовательского интерфейса, добавив дополнительные ограничения для подпредставлений (например, для управления высотой или шириной). Однако следует соблюдать осторожность, чтобы не включать конфликтующие ограничения для тех, которые появились в представлении стека.

<a name="Auto-Layout-and-Size-Classes"></a>

## <a name="auto-layout-and-size-classes"></a>Классы автоматического макета и размера

При добавлении вложенного представления в представление стека его макет полностью управляется этим представлением стека с помощью классов автомакета и размера для размещения и изменения размера упорядоченных представлений.

Представление "стек" _будет закреплять_ первое и Последнее вложенное представление в его коллекции по **верхнему** и **нижнему** краям для вертикальных представлений стека или по **левому** и **правому** краям для горизонтальных представлений стека. Если задать `LayoutMarginsRelativeArrangement` для свойства значение `true` , то представление закрепляет подпредставления на соответствующие поля, а не на границу.

Представление "стек" использует свойство подпредставления `IntrinsicContentSize` при вычислении размера подпредставлений по определенному `Axis` (за исключением `FillEqually Distribution` ). `FillEqually Distribution`Изменяет размеры всех подпросмотров таким образом, чтобы они совпадали с размером, таким образом заполняя представление Stack вдоль `Axis` .

За исключением `Fill Alignment` , представление Stack использует свойство подпредставления `IntrinsicContentSize` для вычисления размера представления, перпендикулярного заданному `Axis` . Для `Fill Alignment` все подпредставления имеют размер, чтобы они заполнили представление стека, перпендикулярное заданному `Axis` .

<a name="Positioning-and-Sizing-the-Stack-View"></a>

## <a name="positioning-and-sizing-the-stack-view"></a>Размещение и изменение размера представления стека

В то время как представление Stack имеет полный контроль над разметкой любого вложенного представления (на основе таких свойств `Axis` , как и `Distribution` ), необходимо по-прежнему располагать представлением стека ( `UIStackView` ) в его родительском представлении, используя классы автоматической разметки и размера.

Как правило, это означает закрепление по крайней мере двух краев представления стека для расширения и контракта, тем самым определяя его расположение. Без каких бы то ни было дополнительных ограничений размер представления стека будет автоматически изменен в соответствии со всеми вложенными представлениями следующим образом:

- Размер по `Axis` сравнению с размером будет суммой всех размеров вложенного представления, а также любого пространства, определенного между каждым вложенным представлением.
- Если `LayoutMarginsRelativeArrangement` свойство имеет значение `true` , размер представлений стека также будет включать в себя пространство для полей.
- Размер, расположенный перпендикулярно, `Axis` будет установлен для самого крупного вложенного представления в коллекции.

Кроме того, можно указать ограничения для **высоты** и **ширины** представления стека. В этом случае вложенные представления будут размещены (в размере) для заполнения пространства, указанного в представлении стека, как определено `Distribution` `Alignment` свойствами и.

Если `BaselineRelativeArrangement` свойство имеет значение `true` , то подпредставления будут размещены на основе базовых показателей первого или последнего подпредставления вместо использования **верхней**, **нижней** или *средней* координаты -  **Y** . Они рассчитываются в содержимом представления стека следующим образом:

- Представление с вертикальным стеком вернет первое Подпредставление для первого базового плана и последний для последнего. Если одно из этих вложенных представлений является представлением стека, то будет использоваться их первый или последний базовый уровень.
- Горизонтальное представление стека будет использовать его самое высокое для первого и последнего базовых показателей. Если максимально высокое представление является также представлением стека, оно будет использовать его в качестве базового.

> [!IMPORTANT]
> Выравнивание по базовому плану не работает для размеров с растяжением или сжатого представления, так как базовый план вычисляется в соответствии с неверной позицией. Для выравнивания по базовому плану убедитесь, что **Высота** подпредставления совпадает с **высотой** внутреннего представления содержимого.

<a name="Common-Stack-View-Uses"></a>

## <a name="common-stack-view-uses"></a>Общее представление "стек" использует

Существует несколько типов макетов, которые хорошо подходят для элементов управления представления стека. В соответствии с Apple, вот несколько наиболее распространенных способов использования:

- **Определите размер вдоль оси** — закрепите оба края в представлении стека `Axis` и один из соседних границ, чтобы задать расположение. представление стека будет увеличиваться вдоль оси в соответствии с пространством, определенным во вложенных представлениях.
- **Определить расположение** вложенного представления. Закрепите к смежным краям представления стека до родительского представления, представление стека будет увеличиваться в обоих измерениях в соответствии с вложенными представлениями.
- **Определить размер и расположение стека** — закрепление всех четырех краев представления стека в родительском представлении. представление стека упорядочивает вложенные представления на основе пространства, определенного в представлении стека.
- **Определите размер перпендикулярно оси** — закрепите оба края, перпендикулярные области представления стека `Axis` , и один из граней вдоль оси, чтобы задать ее расположение, представление стека будет увеличиваться перпендикулярно оси в соответствии с пространством, определенным во вложенных представлениях.

<a name="Stack-Views-and-Storyboards"></a>

## <a name="stack-views-and-storyboards"></a>Представления стека и раскадровки

Самый простой способ работы с представлениями стека в приложении Xamarin. tvOS — добавить их в пользовательский интерфейс приложения с помощью конструктора iOS.

# <a name="visual-studio-for-mac"></a>[Visual Studio для Mac](#tab/macos)

1. В **панель решения** дважды щелкните `Main.storyboard` файл и откройте его для редактирования.
1. Разработайте макет отдельных элементов, которые будут добавлены в представление "стек":

    [![Пример макета элемента](stacked-views-images/layout01.png)](stacked-views-images/layout01.png#lightbox)
1. Добавьте к элементам необходимые ограничения, чтобы обеспечить их правильное масштабирование. Этот шаг важен после добавления элемента в представление стека.
1. Сделайте необходимое число копий (четыре в этом случае):

    [![Необходимое число копий](stacked-views-images/layout02.png)](stacked-views-images/layout02.png#lightbox)
1. Перетащите **представление стека** из **панели элементов** и поместите его в представление:

    [![Представление "стек"](stacked-views-images/layout03.png)](stacked-views-images/layout03.png#lightbox)
1. Выберите представление стека на **вкладке мини** -приложение **панель свойств** выберите **заполнить** для **выравнивания**, **заполните равномерно** для **распределения** и введите `25` для **интервала**:

    [![Вкладка мини-приложения](stacked-views-images/layout04.png)](stacked-views-images/layout04.png#lightbox)
1. Разместите представление стека на экране там, где оно нужно, и добавьте ограничения, чтобы они оставались в нужном месте.
1. Выберите отдельные элементы и перетащите их в представление "стек":

    [![Отдельные элементы в представлении "стек"](stacked-views-images/layout05.png)](stacked-views-images/layout05.png#lightbox)
1. Макет будет скорректирован, и элементы будут упорядочены в представлении стека на основе атрибутов, заданных выше.
1. Назначьте **имена** на **вкладке мини** -приложение **обозревателя свойств** , чтобы работать с элементами управления пользовательского интерфейса в коде C#.
1. Сохраните изменения.

# <a name="visual-studio"></a>[Visual Studio](#tab/windows)

1. В **Обозреватель решений** дважды щелкните `Main.storyboard` файл и откройте его для редактирования.
1. Разработайте макет отдельных элементов, которые будут добавлены в представление "стек":

    [![Пример макета элемента](stacked-views-images/layout01.png)](stacked-views-images/layout01.png#lightbox)
1. Добавьте к элементам необходимые ограничения, чтобы обеспечить их правильное масштабирование. Этот шаг важен после добавления элемента в представление стека.
1. Сделайте необходимое число копий (четыре в этом случае):

    [![Необходимое число копий](stacked-views-images/layout02.png)](stacked-views-images/layout02.png#lightbox)
1. Перетащите **представление стека** из **панели элементов** и поместите его в представление:

    [![Представление "стек"](stacked-views-images/layout03-vs.png)](stacked-views-images/layout03-vs.png#lightbox)
1. Выберите представление стек, на **вкладке мини** -приложение **обозревателя свойств** выберите **заполнить** для **выравнивания**, **заполните равномерное** **распределение** и введите `25` для **интервала**:

    [![Вкладка мини-приложения](stacked-views-images/layout04-vs.png)](stacked-views-images/layout04-vs.png#lightbox)
1. Разместите представление стека на экране там, где оно нужно, и добавьте ограничения, чтобы они оставались в нужном месте.
1. Выберите отдельные элементы и перетащите их в представление "стек":

    [![Отдельные элементы в представлении "стек"](stacked-views-images/layout05-vs.png)](stacked-views-images/layout05-vs.png#lightbox)
1. Макет будет скорректирован, и элементы будут упорядочены в представлении стека на основе атрибутов, заданных выше.
1. Назначьте **имена** на **вкладке мини** -приложение **обозревателя свойств** , чтобы работать с элементами управления пользовательского интерфейса в коде C#.
1. Сохраните изменения.

-----

> [!IMPORTANT]
> Хотя можно назначать такие действия, как `TouchUpInside` элемент пользовательского интерфейса (например, `UIButton` ) в конструкторе iOS при создании обработчика событий, он никогда не будет вызываться, так как Apple TV не имеет сенсорного экрана или поддерживает события касания. `Action Type`При создании действий для элементов пользовательского интерфейса tvOS всегда следует использовать значение по умолчанию.

Дополнительные сведения о работе с раскадровками см. в статье [Hello, tvOS краткое руководство по началу работы](~/ios/tvos/get-started/hello-tvos.md).

В нашем примере мы предоставили розетку и действие для элемента управления "сегмент" и розетку для каждой "карты игрока". В коде мы видим и отображаем проигрыватель на основе текущего сегмента. Пример:

```csharp
partial void PlayerCountChanged (Foundation.NSObject sender) {

    // Take Action based on the segment
    switch(PlayerCount.SelectedSegment) {
    case 0:
        Player1.Hidden = false;
        Player2.Hidden = true;
        Player3.Hidden = true;
        Player4.Hidden = true;
        break;
    case 1:
        Player1.Hidden = false;
        Player2.Hidden = false;
        Player3.Hidden = true;
        Player4.Hidden = true;
        break;
    case 2:
        Player1.Hidden = false;
        Player2.Hidden = false;
        Player3.Hidden = false;
        Player4.Hidden = true;
        break;
    case 3:
        Player1.Hidden = false;
        Player2.Hidden = false;
        Player3.Hidden = false;
        Player4.Hidden = false;
        break;
    }
}
```

При запуске приложения четыре элемента будут равномерно распределяться в нашем представлении Stack:

[![При запуске приложения четыре элемента будут равномерно распределены в представлении Stack.](stacked-views-images/layout06.png)](stacked-views-images/layout06.png#lightbox)

Если число игроков уменьшилось, неиспользуемые представления скрываются, а представление стека корректирует макет таким образом:

[![При уменьшении числа игроков неиспользуемые представления скрываются, а представление стека настраивает макет в соответствии с](stacked-views-images/layout07.png)](stacked-views-images/layout07.png#lightbox)

<a name="Populate-a-Stack-View-from-Code"></a>

### <a name="populate-a-stack-view-from-code"></a>Заполнение представления стека из кода

Помимо определения содержимого и макета представления стека в конструкторе iOS, его можно создать и удалить динамически из кода C#.

Возьмем следующий пример, использующий представление Stack для обработки звездочек в проверке (от 1 до 5):

```csharp
public int Rating { get; set;} = 0;
...

partial void IncreaseRating (Foundation.NSObject sender) {

    // Maximum of 5 "stars"
    if (++Rating > 5 ) {
        // Abort
        Rating = 5;
        return;
    }

    // Create new rating icon and add it to stack
    var icon = new UIImageView (new UIImage("icon.png"));
    icon.ContentMode = UIViewContentMode.ScaleAspectFit;
    RatingView.AddArrangedSubview(icon);

    // Animate stack
    UIView.Animate(0.25, ()=>{
        // Adjust stack view
        RatingView.LayoutIfNeeded();
    });

}

partial void DecreaseRating (Foundation.NSObject sender) {

    // Minimum of zero "stars"
    if (--Rating < 0) {
        // Abort
        Rating =0;
        return;
    }

    // Get the last subview added
    var icon = RatingView.ArrangedSubviews[RatingView.ArrangedSubviews.Length-1];

    // Remove from stack and screen
    RatingView.RemoveArrangedSubview(icon);
    icon.RemoveFromSuperview();

    // Animate stack
    UIView.Animate(0.25, ()=>{
        // Adjust stack view
        RatingView.LayoutIfNeeded();
    });
}
```

Давайте подробно рассмотрим несколько частей этого кода. Сначала мы используем `if` операторы, чтобы проверить наличие не более пяти звездочек или меньше нуля.

Чтобы добавить новую «звезду», мы загружаем его изображение и устанавливаем **режим содержимого** для **масштабирования аспекта**.

```csharp
var icon = new UIImageView (new UIImage("icon.png"));
icon.ContentMode = UIViewContentMode.ScaleAspectFit;
```

Это обеспечивает искажение значка звезды при добавлении в представление стека.

Далее мы добавим новый значок "звезда" в коллекцию вложенных представлений в представлении стека:

```csharp
RatingView.AddArrangedSubview(icon);
```

Обратите внимание, что мы добавили `UIImageView` свойство к `UIStackView` `ArrangedSubviews` свойству, а не к `SubView` . Все представления, которые должны управляться представлением стека, должны быть добавлены в `ArrangedSubviews` свойство.

Чтобы удалить Подпредставление из представления "стек", сначала мы получаем Подпредставление для удаления:

```csharp
var icon = RatingView.ArrangedSubviews[RatingView.ArrangedSubviews.Length-1];
```

Затем необходимо удалить его из `ArrangedSubviews` коллекции и Super View:

```csharp
// Remove from stack and screen
RatingView.RemoveArrangedSubview(icon);
icon.RemoveFromSuperview();
```

Удаление вложенного представления только из `ArrangedSubviews` коллекции происходит из элемента управления представления стека, но не удаляет его с экрана.

<a name="Dynamically-Changing-Content"></a>

## <a name="dynamically-changing-content"></a>Динамическое изменение содержимого

Представление "стек" будет автоматически настраивать макет для подпросмотров при добавлении, удалении или скрытии подпредставления. Макет также будет скорректирован, если изменяется любое свойство представления стека (например, `Axis` ).

Изменения макета можно анимировать, поместив их в блок анимации, например:

```csharp
// Animate stack
UIView.Animate(0.25, ()=>{
    // Adjust stack view
    RatingView.LayoutIfNeeded();
});
```

Многие свойства представления стека можно указать с помощью классов размера в раскадровке. Эти свойства будут автоматически анимированы в ответ на изменения размера или ориентации.

<a name="Summary"></a>

## <a name="summary"></a>Итоги

В этой статье описано проектирование и работа с представлением с накоплением в приложении Xamarin. tvOS.

## <a name="related-links"></a>Связанные ссылки

- [Примеры tvOS](/samples/browse/?products=xamarin&term=Xamarin.iOS%2btvOS)
- [tvOS](https://developer.apple.com/tvos/)
- [Руководства по tvOSму интерфейсу](https://developer.apple.com/tvos/human-interface-guidelines/)
- [Руководством по программированию приложений для tvOS](https://developer.apple.com/library/prerelease/tvos/documentation/General/Conceptual/AppleTV_PG/)