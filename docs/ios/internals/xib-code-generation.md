---
title: Создание кода XIB в Xamarin. iOS
description: В этом документе описывается, как Xamarin. iOS создает код для преобразования файлов ". XIB" в C#, делая визуальные элементы управления доступными программным способом.
ms.prod: xamarin
ms.assetid: 365991A8-E07A-0420-D28E-BC4D32065E1A
ms.technology: xamarin-ios
author: davidortinau
ms.author: daortin
ms.date: 03/21/2017
ms.openlocfilehash: 7e6f0cdab812c65dde1305dbb3d17a7ccdc5c2e1
ms.sourcegitcommit: 4bbf54d2bc1df96af69814e2e5dae47be12e0474
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 03/10/2021
ms.locfileid: "102603104"
---
# <a name="xib-code-generation-in-xamarinios"></a>Создание кода XIB в Xamarin. iOS

Средство Apple Interface Builder Tool («геодоступное») можно использовать для визуального проектирования пользовательских интерфейсов. Определения интерфейса, созданные функцией геохранения, сохраняются в файлах **XIB** . Мини-приложениям и другим объектам в **XIB** -файлах может быть присвоен идентификатор класса, который может быть пользовательским типом, определяемым пользователем. Использование пользовательских типов позволяет настраивать поведение мини-приложений и создавать пользовательские мини-приложения.

Эти классы пользователей обычно являются подклассами классов контроллеров пользовательского интерфейса. Они имеют *возможности* (свойства) и *действия* (события), которые могут быть подключены к объектам интерфейса.
Во время выполнения загружается геообъект. В этот момент создаются объекты, а также операции и действия, которые можно динамически подключать к различным объектам пользовательского интерфейса. При определении этих управляемых классов необходимо определить все действия и функции, чтобы они совпадали с теми, которые предположительно заменяются. Для упрощения кода Visual Studio для Mac использует модель, подобную фоновому коду. Xcode имеет аналогичную модель цели-C. Но модель и соглашения по созданию кода Xamarin. iOS были оптимизированы, чтобы быть более привычными для разработчиков .NET.

## <a name="xib-files-and-custom-classes"></a>Файлы XIB и пользовательские классы

Можно определить пользовательские типы в файлах **XIB** , а также использовать существующие типы из Cocoa Touch. Кроме того, можно использовать типы, определенные в других **XIB** файлах, или полностью в коде C#. В настоящее время Interface Builder не учитывает сведения о типах, определенных за пределами текущего файла **XIB** , поэтому он не перечислит их или не отобразит свои пользовательские розетки и действия. Удаление этого ограничения планируется в будущем.

Пользовательские классы можно определить в **XIB** -файле с помощью команды "добавить подкласс" на вкладке "классы" в Interface Builder. Эти классы называются классами CodeBehind. Если **XIB** -файл содержит аналог файла ". XIB.Designer.cs" в проекте, Visual Studio для Mac автоматически заполнит его определениями разделяемых классов для всех пользовательских классов в **XIB**. Эти разделяемые классы называются "классами конструктора".

## <a name="generating-code"></a>Генерирование кода

Создание кода включается с помощью файла **{0} XIB.Designer.CS** для любого **{0} XIB** -файла с действием сборки *Page*.
Visual Studio для Mac создает разделяемые классы в файле конструктора для всех классов пользователей, которые он может найти в файле **. XIB** . Visual Studio для Mac создает свойства для розеток и разделяемых методов для действий. 

Файл конструктора автоматически обновляется при изменении файла **. XIB** и Visual Studio для Mac восстанавливает фокус. Вносить изменения в файл конструктора не рекомендуется, так как изменения будут перезаписаны в следующий раз, Visual Studio для Mac обновляет файл.

## <a name="registration-and-namespaces"></a>Регистрация и пространства имен

Visual Studio для Mac создает классы конструктора, используя пространство имен по умолчанию проекта для расположения файла конструктора.
Это поведение согласуется с обычным созданием пространства имен проекта .NET.
Пространство имен файлов конструктора использует пространство имен по умолчанию для проекта и его параметры "политики именования .NET". Если пространство имен проекта по умолчанию изменяется, повторно создаваемые классы будут использовать новое пространство имен.
После повторного создания вы можете обнаружить, что разделяемые классы больше не будут соответствовать друг другу.

Чтобы сделать класс обнаруживаемым исполняющей средой цели-C, Visual Studio для Mac применяет `[Register (name)]` атрибут к классу. Хотя Xamarin. iOS автоматически регистрирует `NSObject` производные классы, он использует полные имена .NET. Атрибут, применяемый Visual Studio для Mac, переопределяет поведение Xamarin. iOS, чтобы каждый класс регистрировался с именем, используемым в **XIB** -файле. Добавьте атрибут вручную для всех пользовательских классов, определенных с помощью функции геоконструирования, без использования Visual Studio для Mac для создания файлов конструктора. Это позволит вашим управляемым классам соответствовать ожидаемым именам классов цели-C.

Классы не могут быть определены более чем в одном **. XIB** или конфликтуют.

## <a name="non-designer-class-parts"></a>Части классов, не являющихся конструкторами

Разделяемые классы конструктора не предназначены для использования "как есть". Выходы являются частными, и базовый класс не указан. Предполагается, что каждый класс будет иметь соответствующую часть класса "не-Designer" в другом файле. Файл "без конструктора" задает базовый класс, управляет выходами и определяет конструкторы, необходимые для создания экземпляра класса из машинного кода. Шаблоны Default **. XIB** имеют части класса "не-Designer", но для любых других пользовательских классов, определенных в **XIB**, необходимо добавить элемент, не являющийся конструктором, вручную.

Это разделение с использованием частичных классов требуется для гибкости. Например, несколько классов фонового кода могут создать подкласс общего управляемого абстрактного класса, который подклассировать класс, подклассом которого является.

Обычно классы CodeBehind помещаются в **{0} XIB.CS** -файл рядом с файлом конструктора **{0} XIB.Designer.CS** .

<a name="generated"></a>

## <a name="generated-actions-and-outlets"></a>Созданные действия и розетки

В классах разделяемого конструктора Visual Studio для Mac создает свойства, соответствующие любым подключенным розеткам, определенным в геоотношении, и разделяемые методы, соответствующие любым связанным действиям.

### <a name="outlet-properties"></a>Свойства розетки

Классы конструктора содержат свойства, соответствующие всем розеткам, определенным в пользовательском классе. Эти свойства включают отложенную привязку. Они представляют собой подробные сведения о реализации моста Xamarin. iOS для цели C. Их следует рассматривать как эквивалентные закрытым полям, которые предназначены для использования только из класса CodeBehind. Сделайте поле общедоступным, добавив открытый метод доступа к полю в части класса, не являющейся конструктором.

Если свойства розетки определены как тип `id` (эквивалентный `NSObject` ), генератор кода конструктора в настоящее время определяет наиболее надежный тип, основанный на объектах, подключенных к этой розетке, для удобства.
Однако это поведение может не поддерживаться в будущих версиях. При определении пользовательского класса рекомендуется явно строго вводить эти разъемы.

### <a name="action-properties"></a>Свойства действия

Классы конструктора содержат разделяемые методы, соответствующие всем действиям, определенным в пользовательском классе. Эти методы не имеют реализации. Разделяемые методы являются двойная:

1. Если вы вводите  `partial` в тело класса части класса, не являющегося конструктором, Visual Studio для Mac предоставит Автозаполнение сигнатур всех нереализованных разделяемых методов.
2. Сигнатуры разделяемого метода имеют примененный атрибут, который предоставляет их для мира цели-C, поэтому они могут обрабатываться как соответствующее действие.

Разделяемый метод можно игнорировать и реализовать действие, применив атрибут к другому методу. Или добавим его к базовому классу.

Если для действий определен тип отправителя `id` (эквивалентный `NSObject` ), генератор кода конструктора в настоящее время определяет наиболее надежный тип на основе объектов, подключенных к этому действию. Однако это поведение может не поддерживаться в будущих версиях. Рекомендуется явно строго вводить действия при определении пользовательского класса.

Эти разделяемые методы создаются только для C#, поскольку CodeDOM не поддерживает разделяемые методы. Они не создаются для других языков.

## <a name="cross-xib-class-usage"></a>Использование классов с перекрестными XIB

Иногда пользователям нужно ссылаться на один и тот же класс из нескольких **XIB** файлов, например с помощью контроллеров вкладок. Вы можете явно ссылаться на определение класса из другого **XIB** файла или определить еще одно имя класса во втором **. XIB**.

Последний случай может быть проблематичным из-за Visual Studio для Mac обработки файлов **. XIB** по отдельности. Visual Studio для Mac не может обнаруживать и объединять дубликаты определений. В итоге могут возникнуть конфликты, применяющие атрибут Register несколько раз, если один и тот же разделяемый класс определен в нескольких файлах конструктора. Последние версии Visual Studio для Mac попытаются разрешить конфликты, но они могут не всегда работать должным образом. В будущем такое поведение, скорее всего, станет неподдерживаемым, а Visual Studio для Mac сделает все типы, определенные во всех файлах **. XIB** и управляемом коде в проекте, непосредственно видимыми из всех **XIB** -файлов.

## <a name="type-resolution"></a>Разрешение типов

Типы, используемые в геоуровне, — это имена типов цели-C, сопоставленные с типами CLR с помощью атрибутов Register. При создании кода Visual Studio для Mac будет разрешать типы CLR, полностью подходящие имена типов для типов цели-C. Эти типы цели-C упаковываются ядром Xamarin. iOS.

Генератор кода не может в настоящее время разрешать типы CLR из имен типов цели-C в пользовательском коде или библиотеках. В таких случаях имя типа выводится буквально. Имя должно совпадать с именем типа цели-C, чтобы правильно разрешить тип CLR.
Тип CLR должен находиться в том же пространстве имен, что и код, который его использует. Будущие версии генератора кода будут рассматривать все типы цели-C в проекте.
