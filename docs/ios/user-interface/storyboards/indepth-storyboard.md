---
title: Раскадровки в Xamarin. iOS
description: В этом документе содержатся общие сведения о раскадровках в Xamarin. iOS. Здесь описывается, как раскадровка используется для определения пользовательского интерфейса, переходов и использования конструктора iOS для изменения файлов раскадровки.
ms.prod: xamarin
ms.technology: xamarin-ios
author: davidortinau
ms.author: daortin
ms.date: 03/22/2017
ms.openlocfilehash: b9e0f5d01d7843c25af3af3cddefbe0740f018a3
ms.sourcegitcommit: 513feb0e07558766e3de4a898e53d56b27c20559
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/22/2021
ms.locfileid: "98697518"
---
# <a name="storyboards-in-xamarinios"></a>Раскадровки в Xamarin. iOS

В этом разделе вы узнаете, что такое раскадровка и как изучить некоторые ключевые компоненты, например переходов. Мы рассмотрим, как можно создавать и использовать раскадровки и какие преимущества они имеют для разработчика.

Прежде чем формат файла раскадровки появился в Apple как визуальное представление пользовательского интерфейса приложения iOS, разработчики создали файлы XIB для каждого контроллера представления и запустили навигацию между представлениями вручную.  Использование раскадровки позволяет разработчику определять как контроллеры представлений, так и навигацию между ними в области конструктора и обеспечивает редактирование пользовательского интерфейса приложения в режиме WYSIWYG.

Раскадровку можно создать и открыть с помощью Visual Studio для Mac. В этом руководстве также рассматривается использование Interface Builder Xcode для создания раскадровок с использованием C# для программирования навигации.

## <a name="requirements"></a>Требования

Раскадровки можно использовать с Xcode и запускать из проекта Xamarin. iOS на Visual Studio для Mac.

## <a name="what-is-a-storyboard"></a>Что такое раскадровка?

Раскадровка — это визуальное представление всех экранов в приложении. Он содержит последовательность сцен, где каждая сцена представляет *контроллер представления* и его *представления*. Эти представления могут содержать объекты и [элементы управления](~/ios/user-interface/controls/index.md) , позволяющие пользователю взаимодействовать с приложением. Эта коллекция представлений и элементов управления (или вложенных *представлений*) называется *иерархией представления содержимого*. Сцены соединяются объектами перехода, которые представляют переход между контроллерами представления. Обычно это достигается путем создания перехода между объектом в первоначальном представлении и представлением соединения. Связи в области конструктора показаны на следующем рисунке:

 [![В этом изображении показаны связи в области конструктора.](images/storyboardsview.png)](images/storyboardsview.png#lightbox)

Как видно, раскадровка размещается в каждом из сцен с уже подготовленным содержимым и иллюстрирует соединения между ними. Когда мы говорим о сценах на iPhone, можно спокойно предположить, что одна *сцена* на раскадровке равна одному *экрану* содержимого на устройстве. Однако в случае с iPad может отображаться несколько сцен одновременно, например с помощью контроллера представления контекстном меню Action.

Использование раскадровки дает множество преимуществ для создания пользовательского интерфейса приложения, особенно при использовании Xamarin. Во-первых, это визуальное представление пользовательского интерфейса, так как все объекты, включая [пользовательские элементы управления](../designer/ios-designable-controls-overview.md) , подготавливаются к просмотру во время разработки.
Это означает, что перед сборкой или развертыванием приложения можно визуализировать его внешний вид и последовательность. Возьмем, к примеру, предыдущий образ. В области конструктора можно узнать, сколько сцен есть, макет каждого представления и как все связано. Это делает раскадровки настолько мощными.

Вы также можете управлять событиями с помощью раскадровок.  Большинство элементов управления пользовательского интерфейса имеют список возможных событий в Панель свойств. Обработчик событий можно добавить и выполнить в разделяемом методе класса View Controllers.

Содержимое раскадровки хранится в виде XML-файла. Во время сборки все `.storyboard` файлы компилируются в двоичные файлы, называемые нибс. Во время выполнения эти нибс инициализируются и создаются для создания новых представлений.

## <a name="segues"></a>Переходов

Объект *перехода* или *перехода* используется в разработке iOS для представления перехода между сценами. Чтобы создать перехода, удерживайте нажатой клавишу **CTRL** и перетащите ее с одной сцены на другую. При перетаскивании мыши появляется синий соединитель, указывающий, где будет перехода. Это показано на следующем рисунке:

 [![Появится синий соединитель, указывающий, где перехода будет выглядеть, как показано на этом изображении.](images/createsegue.png)](images/createsegue.png#lightbox)

При наведении указателя мыши появляется меню, позволяющее выбрать действие для перехода. Он может выглядеть примерно так, как показано на следующих рисунках:

**Классы до iOS 8 и size**:

[![Раскрывающийся список действия перехода без классов размера](images/segue1.png)](images/segue1.png#lightbox)

**При использовании классов размера и адаптивного переходов**:

[![Раскрывающийся список действия перехода с классами size](images/16new.png)](images/16new.png#lightbox)

> [!IMPORTANT]
> Если вы используете VMWare для виртуальной машины Windows, при нажатии _кнопки мыши по умолчанию отображается_ нажатие клавиши CTRL. Чтобы создать перехода, измените параметры клавиатуры с помощью **параметров**  >  **Клавиатура & мышь**  >   и переназначьте **вторичную кнопку** , как показано ниже:
>
> [![Параметры настройки клавиатуры и мыши](images/image22.png)](images/image22.png#lightbox)
>
> Теперь вы можете добавить перехода между контроллерами представления как обычно.

Существуют различные типы переходов, каждый из которых обеспечивает контроль над представлением нового контроллера представления пользователю и тем, как он взаимодействует с другими контроллерами представления в раскадровке. Они описаны ниже. Также можно создать подкласс для объекта перехода, чтобы реализовать пользовательский переход:

- **Показать/отправить** — Push-перехода добавляет контроллер представления в стек навигации. Предполагается, что контроллер представления, исходящий из отправки push, является частью того же контроллера навигации, что и контроллер представления, добавляемый в стек. Это делает то же самое  `pushViewController` , что и, и обычно используется при наличии некоторой связи между данными на экранах. Использование push перехода дает вам Люкс с панелью навигации с кнопкой "назад" и заголовком, добавленными в каждое представление в стеке, что позволяет детализировать навигацию по иерархии представлений.
- **Модальный** — модальный перехода создает связь между любыми двумя контроллерами представления в проекте с возможностью отображения анимированного перехода. Контроллер дочернего представления будет полностью скрывать родительский контроллер представления при просмотре. В отличие от Push-перехода, в котором добавляется кнопка назад для нас, при `DismissViewController` использовании модального перехода для возврата к предыдущему контроллеру представления необходимо использовать.
- **Custom** — любой пользовательский перехода можно создать как подкласс `UIStoryboardSegue` .
- **Очистка** — перехода очистки можно использовать для перехода по Push-или модальным перехода, например путем закрытия модального контроллера представления. Помимо этого, вы можете очистить не только одну, но и серию push-и модальных переходов, а также выполнить несколько шагов в иерархии навигации с одним действием очистки. Чтобы понять, как использовать перехода очистки в iOS, прочитайте статью создание рецепта  [очистки переходов](https://github.com/xamarin/recipes/tree/master/Recipes/ios/general/storyboard/unwind_segue) .
- Без **исходного кода** — перехода без исходного кода указывает на сцену, содержащую исходный контроллер представления, и поэтому представление, которое пользователь увидит первым. Он представлен в перехода, показанном здесь:

    [![Перехода с исходным кодом](images/sourcelesssegue.png)](images/sourcelesssegue.png#lightbox)

### <a name="adaptive-segue-types"></a>Адаптивные типы перехода

 в iOS 8 появились [классы размера](../storyboards/unified-storyboards.md#size-classes) , позволяющие файлу раскадровки iOS работать со всеми доступными размерами экрана, что позволяет разработчикам создавать один пользовательский интерфейс для всех устройств iOS. По умолчанию все новые приложения Xamarin. iOS используют классы size. Чтобы использовать классы размеров из более старых проектов, ознакомьтесь с руководством [Введение в унифицированные раскадровки](~/ios/user-interface/storyboards/unified-storyboards.md) .

В любом приложении, использующем классы размера, также будет использоваться новое [*Адаптивное переходов*](unified-storyboards.md). При использовании классов размера Помните, что вы не указываете, используете ли вы iPhone или iPad. Иными словами, вы создаете один пользовательский интерфейс, который всегда будет выглядеть одинаково, независимо от того, насколько реально он должен работать. Адаптивное переходов работает, судя среду и определяя, как лучше представлять содержимое. Ниже приведены адаптивные переходов.

[![Раскрывающееся меню адаптивного переходов](images/adaptivesegue.png)](images/adaptivesegue.png#lightbox)

|Перехода|Описание|
|--- |--- |
|Показать|Это очень похоже на Push-перехода, но оно принимает содержимое экрана в учетную запись.|
|Отобразить подробности|Если приложение отображает главное и подробное представление (например, в контроллере с разделением представлений на iPad), содержимое заменит подробное представление. Если приложение отображает только основные сведения или подробности, содержимое будет заменено верхней частью стека контроллера представления.|
|Уровень представления|Это похоже на модальный перехода и позволяет выбирать стили представления и перехода.|
|Контекстном меню Action презентацию|Это содержимое представлено как контекстном меню Action.|

### <a name="transferring-data-with-segues"></a>Передача данных с помощью переходов

Преимущества перехода не заканчиваются переходами. Они также могут использоваться для управления переносом данных между контроллерами представления. Это достигается путем переопределения `PrepareForSegue` метода для первоначального контроллера представления и самостоятельной обработки данных. При активации перехода (например, при нажатии кнопки) приложение вызывает этот метод, предоставляя возможность подготовить новый контроллер представления *перед* переходом. В следующем коде из примера [Phoneword](/samples/xamarin/ios-samples/hello-ios) показано следующее:

```csharp
public override void PrepareForSegue (UIStoryboardSegue segue,
NSObject sender)
{
    base.PrepareForSegue (segue, sender);

    var callHistoryController = segue.DestinationViewController
                                  as CallHistoryController;

    if (callHistoryController != null) {
        callHistoryController.PhoneNumbers = PhoneNumbers;
    }
}
```

В этом примере `PrepareForSegue` метод будет вызываться при активации перехода пользователем. Сначала необходимо создать экземпляр контроллера представления "получение" и задать его в качестве целевого контроллера представления перехода. Это делается следующей строкой кода:

```csharp
var callHistoryController = segue.DestinationViewController as CallHistoryController;
```

Теперь метод может задавать свойства в `DestinationViewController` . Этот пример использует эту возможность, передавая список с именем в `PhoneNumbers` `CallHistoryController` объект и назначив его объекту с таким же именем:

```csharp
if (callHistoryController != null) {
        callHistoryController.PhoneNumbers = PhoneNumbers;
    }
```

После завершения перехода пользователь увидит `CallHistoryController` список с заполненным списком.

## <a name="adding-a-storyboard-to-a-non-storyboard-project"></a>Добавление раскадровки в проект, не являющийся раскадровкой

В некоторых случаях может потребоваться добавить раскадровку в ранее не раскадровой файл. Процесс можно упростить в Visual Studio для Mac, выполнив следующие действия.

# <a name="visual-studio-for-mac"></a>[Visual Studio для Mac](#tab/macos)

1. Создайте файл раскадровки, перейдя в **файл > новый файл > iOS > Storyboard**.

    [![Диалоговое окно «Создание файла»](images/new-storyboard-xs.png)](images/new-storyboard-xs.png#lightbox)

2. Добавьте имя раскадровки в раздел " **основной интерфейс** " файла **info. plist**.

    [![Редактор info. plist](images/infoplist.png)](images/infoplist.png#lightbox)

    Это эквивалентно созданию экземпляра исходного контроллера представления в `FinishedLaunching` методе в делегате приложения. Если этот параметр установлен, приложение создает экземпляр окна (см. следующий шаг), загружает основную раскадровку и назначает экземпляр исходного контроллера представления раскадровки (рядом с перехода без источника) в качестве `RootViewController` Свойства окна. Затем окно становится видимым на экране.

3. В `AppDelegate` Переопределите метод по умолчанию `Window` следующим кодом, чтобы реализовать свойство Window:

    ```csharp
    public override UIWindow Window {
        get;
        set;
    }
    ```

# <a name="visual-studio"></a>[Visual Studio](#tab/windows)

1. Создайте файл раскадровки, щелкнув правой кнопкой мыши проект, чтобы **добавить > новый файл > iOS > пустая раскадровка**.

    [![Диалоговое окно "новый элемент"](images/new-storyboard-vs.png)](images/new-storyboard-vs.png#lightbox)

2. Добавьте имя раскадровки в раздел " **основной интерфейс** " приложения iOS.

    [![Редактор info. plist](images/ios-app.png)](images/ios-app.png#lightbox)

    Это эквивалентно созданию экземпляра исходного контроллера представления в `FinishedLaunching` методе в делегате приложения. Если этот параметр установлен, приложение создает экземпляр окна (см. следующий шаг), загружает основную раскадровку и назначает экземпляр исходного контроллера представления раскадровки (рядом с перехода без источника) в качестве `RootViewController` Свойства окна. Затем окно становится видимым на экране.

3. В `AppDelegate` Переопределите метод по умолчанию `Window` следующим кодом, чтобы реализовать свойство Window:

    ```csharp
    public override UIWindow Window {
        get;
        set;
    }
    ```

-----

## <a name="creating-a-storyboard-with-xcode"></a>Создание раскадровки с помощью Xcode

Раскадровку можно создать и изменить с помощью Xcode для использования в приложениях iOS, разработанных с помощью Visual Studio для Mac.

Раскадровки полностью заменяют отдельные файлы XIB в проекте, однако отдельные контроллеры представлений в раскадровке можно создавать с помощью `Storyboard.InstantiateViewController` .

Иногда приложения имеют особые требования, которые не могут быть обработаны с помощью встроенных переходов раскадровки, предоставляемых конструктором. Например, если необходимо создать приложение, которое запускает различные экраны из одной кнопки, в зависимости от текущего состояния приложения может потребоваться вручную создать экземпляры контроллеров представления и самостоятельно программировать переход.

На следующем снимке экрана показаны два контроллера представления в области конструктора без перехода между ними. В следующем разделе показано, как можно настроить переход в коде.

1. Добавить _пустую раскадровку iPhone_ в существующий проект проекта:

    [![Добавление раскадровки](images/add-storyboard2.png)](images/add-storyboard2.png#lightbox)

2. Щелкните файл раскадровки правой кнопкой мыши и выберите пункт **Открыть с помощью > Xcode Interface Builder** , чтобы открыть его в Xcode.

   > Советы Если вы предпочитаете использовать построитель интерфейсов Xcode по умолчанию, его можно выбрать в параметрах Visual Studio для Mac в разделе **проекты > iOS**.  Начиная с Visual Studio версии 16,9 и Visual Studio для Mac 8,9, единственным вариантом будет Xcode Interface Builder. *

   ![Выбор предпочтительного средства конструктора.](images/set-preferred-designer-tool.png)

3. В Xcode Откройте библиотеку (с помощью **представления > Показать библиотеку** или **Shift + Command + L**), чтобы отобразить список объектов, которые можно добавить в раскадровку. Добавьте в `Navigation Controller` раскадровку, перетащив объект из списка на раскадровку. По умолчанию в `Navigation Controller` будет представлено два экрана. Справа находится экран, `TableViewController` который будет заменен более простым представлением, поэтому его можно удалить, щелкнув представление и нажав клавишу DELETE.

    [![Добавление Навигатионконтроллер из библиотеки](images/add-navigation-controller.png)](images/add-navigation-controller.png#lightbox)

4. Этот контроллер представления будет иметь собственный пользовательский класс, а также должен иметь собственный идентификатор раскадровки. Если щелкнуть поле над вновь добавленным представлением, то появится три значка, крайний левый из которых представляет контроллер представления для представления. Выбрав этот значок, можно задать значения класса и идентификатора на вкладке удостоверение на правой панели. Задайте для этих значений значение `MainViewController` и убедитесь, что проверка `Use Storyboard ID` .

    [![Настройка Маинвиевконтроллер на панели удостоверений](images/identity-panel.png)](images/identity-panel.png#lightbox)

5. Снова с помощью библиотеки перетащите на экран элемент управления контроллера представления. Он будет установлен в качестве контроллера корневого представления. Нажимая клавишу **Control** , щелкните и перетащите значок из контроллера навигации слева к добавленному контроллеру представления справа и выберите **корневой контроллер представления** в меню.

    [![Добавление Навигатионконтроллер из библиотеки и задание Маинвиевконтроллер в качестве корневого контроллера представления](images/add-view-controller.png)](images/add-view-controller.png#lightbox)

6. Это приложение будет переходить к другому представлению, поэтому добавьте еще одно представление в раскадровку, как и раньше. Вызовите его `PinkViewController` и задайте эти значения так же, как и в `MainViewController` .

    [![На снимке экрана показана раскадровка с тремя представлениями.](images/add-additional-view-controller.png)](images/add-additional-view-controller.png#lightbox)

7. Так как контроллер представления будет иметь розовый фон, задайте это свойство на панели Атрибуты, используя раскрывающийся список рядом с `Background` .

    [![На снимке экрана показана раскадровка из предыдущего шага с самым крайним экраном, измененным на розовый фон.](images/set-pink-background.png)](images/set-pink-background.png#lightbox)

8. Так как мы хотим `MainViewController` , чтобы объект мог переходить к `PinkViewController` , для первого потребуется кнопка для взаимодействия с. Используйте библиотеку, чтобы добавить кнопку в `MainViewController` .

    [![Добавление кнопки в Маинвиевконтроллер](images/add-button.png)](images/add-button.png#lightbox)

Раскадровка завершена, но если развернуть проект сейчас, вы получите пустой экран. Это связано с тем, что вам по-прежнему нужно сообщить интегрированной среде разработки использовать раскадровку и настроить корневой контроллер представления, который будет служить первым представлением. Обычно это можно сделать с помощью параметров проекта, как показано выше. Однако в этом примере мы добавим следующий код в **AppDelegate** для достижения того же результата:

```csharp
public partial class AppDelegate : UIApplicationDelegate
{
    UIWindow window;
    public static UIStoryboard Storyboard = UIStoryboard.FromName ("MainStoryboard", null);
    public static UIViewController initialViewController;

    public override bool FinishedLaunching (UIApplication app, NSDictionary options)
    {
        window = new UIWindow (UIScreen.MainScreen.Bounds);

        initialViewController = Storyboard.InstantiateInitialViewController () as UIViewController;

        window.RootViewController = initialViewController;
        window.AddSubview(initialViewController.View);
        window.MakeKeyAndVisible ();
        return true;
    }
}
```

Это большой объем кода, но незнакомо всего несколько строк. Сначала зарегистрируйте раскадровку с помощью **AppDelegate** , передав имя раскадровки **файл mainstoryboard**. Далее вы указываете приложению создать экземпляр исходного контроллера представления из раскадровки путем вызова `InstantiateInitialViewController` в раскадровке, а также задать этот контроллер представления в качестве корневого контроллера представления приложения. Этот метод определяет первый экран, который видит пользователь, и создает новый экземпляр этого контроллера представления.

Обратите внимание на область решения, в которой среда разработки создала `MainViewcontroller.cs` класс и соответствующий `*.designer.cs` файл при добавлении имени класса в панель свойств на шаге 4. Этот класс создал специальный конструктор, включающий базовый класс:

```csharp
public MainViewController (IntPtr handle) : base (handle)
{
}
```

При создании раскадровки с помощью Xcode интегрированная среда разработки автоматически добавляет атрибут [[Register]](xref:Foundation.RegisterAttribute) в начало `*.designer.cs` класса и передает строковый идентификатор, идентичный идентификатору раскадровки, указанному на предыдущем шаге. При этом C# будет связан с соответствующей сценой в раскадровке.

```csharp
[Register ("MainViewController")]
public partial class MainViewController : UIViewController
{
    public MainViewController (IntPtr handle) : base (handle)
    {
    }
    //...
}
```

Дополнительные сведения о регистрации классов и методов см. в разделе [регистратор типов](../../internals/registrar.md).

Последний шаг в этом классе — подключить кнопку и переход к контроллеру розового представления. Вы создадите экземпляр `PinkViewController` из раскадровки, а затем запрограммироване Push-перехода с помощью `PushViewController` , как показано в следующем примере кода:

```csharp
public partial class MainViewController : UIViewController
{
    UIViewController pinkViewController;

    public MainViewController (IntPtr handle) : base (handle)
    {
    }

    public override void AwakeFromNib ()
    {
        // Called when loaded from xib or storyboard.
        this.Initialize ();
    }

    public void Initialize()
    {
        //Instantiating View Controller with Storyboard ID 'PinkViewController'
        pinkViewController = Storyboard.InstantiateViewController ("PinkViewController") as PinkViewController;
    }

    public override void ViewDidLoad ()
    {
        base.ViewDidLoad ();

        //When we push the button, we will push the pinkViewController onto our current Navigation Stack
        PinkButton.TouchUpInside += (o, e) =&gt;
        {
            this.NavigationController.PushViewController (pinkViewController, true);
        };
    }
}
```

При запуске приложения создается 2-экранное приложение:

![Экраны запуска примера приложения](images/finishedstoryboard.png)

## <a name="conditional-segues"></a>Условное переходов

Часто переход с одного контроллера представления на другой зависит от определенного условия. Например, если мы представили простой экран входа, мы хотим перейти к следующему экрану, только *Если* имя пользователя и пароль были проверены.

В следующем примере мы добавим поле Password (пароль) к предыдущему примеру. Пользователь сможет получить доступ к *пинквиевконтроллер* только в том случае, если он введет правильный пароль, в противном случае появится сообщение об ошибке.

Прежде чем начать, выполните предыдущие шаги 1 – 8. В этих шагах мы создадим нашу раскадровку, начнем с создания пользовательского интерфейса и говорим представителю приложения, какой контроллер представления следует использовать в качестве своего Рутвиевконтроллер.

1. Теперь создадим пользовательский интерфейс и добавим в него дополнительные представления `MainViewController` , которые будут выглядеть так, как показано на снимке экрана ниже:

    - UITextField
        - Имя: Пассвордтекстфиелд
        - Заполнитель: ' введите пароль для секрета '
    - UILabel
        - Текст: ошибка: неправильный пароль. Вы не должны пройти! '
        - Цвета: красный.
        - Выравнивание: по центру
        - Строки: 2
        - Флажок "Hidden" установлен    

    [![Центрированные линии](images/passwordvc.png)](images/passwordvc.png#lightbox)

2. Создайте перехода между кнопкой "перейти к розовый" и контроллером представления, перетащив элемент управления из *пинкбуттон* в *пинквиевконтроллер*, а затем выбрав пункт **Push-уведомления** при нажатии кнопки мыши.

3. Щелкните перехода и присвойте ему *идентификатор* `SegueToPink` :

    [![Щелкните перехода и присвойте ему идентификатор Сегуетопинк](images/namesegue.png)](images/namesegue.png#lightbox)  

4. Наконец, добавьте в `ShouldPerformSegue` класс следующий метод `MainViewController` :

    ```csharp
    public override bool ShouldPerformSegue (string segueIdentifier, NSObject sender)
    {

        if(segueIdentifier == "SegueToPink"){
            if (PasswordTextField.Text == "password") {
                PasswordTextField.ResignFirstResponder ();
                return true;
            }
            else{
                ErrorLabel.Hidden = false;
                return false;
            }
        }
        return base.ShouldPerformSegue (segueIdentifier, sender);
    }
    ```

В этом коде мы сосегуеидентифиерся с нашим `SegueToPink` перехода, поэтому мы можем протестировать условие, в данном случае — действительный пароль. Если наше условие возвращает `true` , перехода выполняет и представляет `PinkViewController` . Если `false` значение равно, новый контроллер представления не будет представлен.

Этот подход можно применить к любому перехода в этом контроллере представления, установив значение аргумента Сегуеидентифиер в метод Шаулдперформсегуе. В этом случае у нас есть только один идентификатор перехода — `SegueToPink` .

См. условное решение Storyboard. Conditional в [примере раскадровки вручную](/samples/xamarin/ios-samples/manualstoryboard) для рабочего примера.

## <a name="summary"></a>Сводка

В этой статье описывается концепция раскадровок и их преимущества при разработке приложений iOS. В нем обсуждаются сцены, контроллеры представлений, представления и иерархии представлений, а также принципы связывания сцен с различными типами переходов.  Кроме того, в нем рассматривается ручное создание экземпляров контроллеров представлений из раскадровки и создание условного переходов.

## <a name="related-links"></a>Связанные ссылки

- [Ручная Раскадровка (пример)](/samples/xamarin/ios-samples/manualstoryboard/)
- [Общие сведения о конструкторе iOS](../designer/introduction.md)
- [Преобразование в раскадровки](https://developer.apple.com/library/ios/#releasenotes/Miscellaneous/RN-AdoptingStoryboards/)
- [Справочник по классам Уисторибоард](https://developer.apple.com/library/ios/#documentation/UIKit/Reference/UIStoryboard_Class/Reference/Reference.html)
