---
title: Пользовательские элементы управления в Xamarin Designer для iOS
description: Xamarin Designer для iOS поддерживает визуализацию пользовательских элементов управления, созданных в проекте, или ссылок из внешних источников, таких как хранилище компонентов Xamarin.
ms.prod: xamarin
ms.assetid: D8F07D63-B006-4050-9D1B-AC6FCDA71B99
ms.technology: xamarin-ios
author: davidortinau
ms.author: daortin
ms.date: 03/22/2017
ms.openlocfilehash: 593f03588d691071d4a231d9ed788391530d5608
ms.sourcegitcommit: d1f0e0a9100548cfe0960ed2225b979cc1d7c28f
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 12/01/2020
ms.locfileid: "96439426"
---
# <a name="custom-controls-in-the-xamarin-designer-for-ios"></a>Пользовательские элементы управления в Xamarin Designer для iOS

_Xamarin Designer для iOS поддерживает визуализацию пользовательских элементов управления, созданных в проекте, или ссылок из внешних источников, таких как хранилище компонентов Xamarin._

> [!WARNING]
> Конструктор iOS будет запущен в Visual Studio 2019 версии 16,8 и Visual Studio 2019 для Mac версии 8,8.
> Рекомендуемый способ создания пользовательских интерфейсов iOS — непосредственно на компьютере Mac с Xcode. Дополнительные сведения см. в разделе [Разработка пользовательских интерфейсов с помощью Xcode](../storyboards/index.md). 

Xamarin Designer для iOS является мощным средством для визуализации пользовательского интерфейса приложения и обеспечивает поддержку редактирования в режиме WYSIWYG для большинства представлений iOS и контроллеров представлений. Приложение также может содержать пользовательские элементы управления, расширяющие встроенные в iOS. Если эти пользовательские элементы управления написаны с учетом нескольких рекомендаций, они также могут быть отображены в конструкторе iOS, предоставляя даже более широкие возможности редактирования. В этом документе рассматриваются эти рекомендации.

## <a name="requirements"></a>Требования

В области конструктора будут отображены элементы управления, соответствующие следующим требованиям.

1. Это прямой или косвенный подкласс  [UIView](xref:UIKit.UIView) или  [UIViewController](xref:UIKit.UIViewController). Другие подклассы [нсобжект](xref:Foundation.NSObject) будут отображаться в виде значка в области конструктора.
2. Он имеет  [регистераттрибуте](xref:Foundation.RegisterAttribute) , чтобы предоставить его цели — C.
3. У него есть  [обязательный конструктор IntPtr](~/ios/internals/api-design/index.md).
4. Он либо реализует интерфейс [IComponent](xref:System.ComponentModel.IComponent) , либо имеет для [десигнтимевисиблеаттрибуте](xref:System.ComponentModel.DesignTimeVisibleAttribute) значение true.

Элементы управления, определенные в коде, отвечающие приведенным выше требованиям, будут отображаться в конструкторе при компиляции содержащего их проекта для симулятора. По умолчанию все пользовательские элементы управления отображаются в разделе **пользовательские компоненты** **области элементов**. Однако [категоряттрибуте](xref:System.ComponentModel.CategoryAttribute) можно применить к классу пользовательского элемента управления, чтобы указать другой раздел.

Конструктор не поддерживает загрузку сторонних библиотек цели-C.

## <a name="custom-properties"></a>Пользовательские свойства

Свойство, объявленное настраиваемым элементом управления, будет отображаться на панели свойств, если выполняются следующие условия.

1. Свойство имеет открытый метод получения и задания.
1. Свойство имеет  [експортаттрибуте](xref:Foundation.ExportAttribute) , а  [Бровсаблеаттрибуте](xref:System.ComponentModel.BrowsableAttribute) — значение true.
1. Тип свойства — числовой тип, тип перечисления, String, bool, [SizeF](xref:System.Drawing.SizeF), [уиколор](xref:UIKit.UIColor)или [уиимаже](xref:UIKit.UIImage). Этот список поддерживаемых типов может быть расширен в будущем.

Свойство также можно снабдить [дисплайнамеаттрибуте](xref:System.ComponentModel.DisplayNameAttribute) , чтобы указать метку, которая будет отображаться на панели свойств.

## <a name="initialization"></a>Инициализация

Для `UIViewController` подклассов следует использовать метод [ViewDidLoad](xref:UIKit.UIViewController.ViewDidLoad) для кода, который зависит от представлений, созданных в конструкторе.

Для `UIView` и других `NSObject` подклассов метод [авакефромниб](xref:Foundation.NSObject.AwakeFromNib) является рекомендуемым местом для инициализации пользовательского элемента управления после его загрузки из файла макета. Это обусловлено тем, что пользовательские свойства, заданные на панели свойств, не будут заданы при запуске конструктора элемента управления, но будут установлены перед `AwakeFromNib` вызовом:

```csharp
[Register ("CustomView"), DesignTimeVisible (true)]
public class CustomView : UIView {

    public CustomView (IntPtr handle) : base (handle) { }

    public override void AwakeFromNib ()
    {
        // Initialize the view here.
    }
}
```

Если элемент управления также предназначен для создания непосредственно из кода, может потребоваться создать метод, имеющий общий код инициализации, например:

```csharp
[Register ("CustomView"), DesignTimeVisible (true)]
public class CustomView : UIView {

    public CustomView (IntPtr handle) : base (handle) { }

    public CustomView ()
    {
        // Called when created from code.
        Initialize ();
    }

    public override void AwakeFromNib ()
    {
        // Called when loaded from xib or storyboard.
        Initialize ();
    }

    void Initialize ()
    {
        // Common initialization code here.
    }
}
```

## <a name="property-initialization-and-awakefromnib"></a>Инициализация и Авакефромниб свойств

Следует принять во внимание, когда и где следует инициализировать создаваемые свойства в пользовательском компоненте так, чтобы не перезаписать значения, заданные в конструкторе iOS. В качестве примера рассмотрим следующий код:

```csharp
[Register ("CustomView"), DesignTimeVisible (true)]
public class CustomView : UIView {

    [Export ("Counter"), Browsable (true)]
    public int Counter {get; set;}

    public CustomView (IntPtr handle) : base (handle) { }

    public CustomView ()
    {
        // Called when created from code.
        Initialize ();
    }

    public override void AwakeFromNib ()
    {
        // Called when loaded from xib or storyboard.
        Initialize ();
    }

    void Initialize ()
    {
        // Common initialization code here.
        Counter = 0;
    }
}
```

`CustomView`Компонент предоставляет `Counter` свойство, которое может быть задано разработчиком в конструкторе iOS. Однако независимо от того, какое значение задано в конструкторе, значение `Counter` свойства всегда будет равно нулю (0). Далее описывается, почему это происходит:

- Экземпляр класса из  `CustomControl` файла раскадровки.
- Задаются все свойства, измененные в конструкторе iOS (например, установка значения  `Counter` двух (2)).
- `AwakeFromNib`Выполняется метод и выполняется вызов `Initialize` метода компонента.
- В  `Initialize` значении  `Counter` свойства сбрасывается до нуля (0).

Чтобы устранить описанную выше ситуацию, либо инициализируйте `Counter` свойство в любом расположении (например, в конструкторе компонента), либо не переопределяйте `AwakeFromNib` метод и вызовите, `Initialize` если компоненту не требуется дальнейшая инициализация вне зависимости от того, что в данный момент обрабатывается конструкторами.

## <a name="design-mode"></a>Режим конструктора

В области конструктора пользовательский элемент управления должен соответствовать некоторым ограничениям:

- Ресурсы пакета приложений недоступны в режиме конструктора. Изображения доступны при загрузке с помощью  [методов уиимаже](xref:UIKit.UIImage) .
- Асинхронные операции, такие как веб-запросы, не должны выполняться в режиме конструктора. Область конструктора не поддерживает анимацию или другие асинхронные обновления пользовательского интерфейса элемента управления.

Пользовательский элемент управления может реализовать [IComponent](xref:System.ComponentModel.IComponent) и использовать свойство [десигнмоде](xref:System.ComponentModel.ISite.DesignMode) для проверки того, находится ли он в области конструктора. В этом примере метка будет отображать «режим конструктора» в области конструктора и «Runtime» во время выполнения:

```csharp
[Register ("DesignerAwareLabel")]
public class DesignerAwareLabel : UILabel, IComponent {

    #region IComponent implementation

    public ISite Site { get; set; }
    public event EventHandler Disposed;

    #endregion

    public DesignerAwareLabel (IntPtr handle) : base (handle) { }

    public override void AwakeFromNib ()
    {
        if (Site != null && Site.DesignMode)
            Text = "Design Mode";
        else
            Text = "Runtime";
    }
}
```

`Site` `null` Прежде чем пытаться получить доступ к любому из его членов, следует всегда проверять свойство. Если `Site` имеет значение `null` , то можно спокойно предположить, что элемент управления не выполняется в конструкторе.
В режиме конструктора `Site` будет установлен после вызова конструктора элемента управления и перед `AwakeFromNib` вызовом метода.

## <a name="debugging"></a>Отладка

Элемент управления, соответствующий указанным выше требованиям, будет отображаться на панели элементов и отображен на поверхности.
Если элемент управления не отображается, проверьте наличие ошибок в элементе управления или одну из его зависимостей.

Область конструктора часто может перехватывать исключения, создаваемые отдельными элементами управления, продолжая отображать другие элементы управления. Элемент управления, вызвавший сбой, заменяется красным заполнительом, и вы можете просмотреть трассировку исключений, щелкнув значок с восклицательным знаком:

 ![Элемент управления с ошибками как красный заполнитель и сведения об исключении](ios-designable-controls-overview-images/exception-box.png)

Если для элемента управления доступны отладочные символы, то трассировка будет содержать имена файлов и номера строк.
Двойной щелчок по строке в трассировке стека приведет к переходу к этой строке в исходном коде.

Если конструктор не может изолировать неисправный элемент управления, в верхней части области конструктора появится предупреждающее сообщение:

 ![Предупреждающее сообщение в верхней части области конструктора](ios-designable-controls-overview-images/info-bar.png)

Полная визуализация возобновится, когда неисправный элемент управления будет исправлен или удален из области конструктора.

## <a name="summary"></a>Сводка

В этой статье представлено создание и применение пользовательских элементов управления в конструкторе iOS. Сначала в нем описаны требования, которым должны соответствовать элементы управления для подготовки к просмотру в области конструктора и предоставления настраиваемых свойств на панели свойств. Затем он просматривает код программной части для инициализации элемента управления и свойства Десигнмоде. В последний раз было описано, что происходит при возникновении исключений и как устранить эту проблему.
