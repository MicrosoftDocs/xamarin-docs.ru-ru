---
title: Механизм сборки iOS
description: В этом руководстве описано, как планировать приложения и использовать методы, которые можно применять для ускоренного создания сборок для всех конфигураций.
ms.prod: xamarin
ms.assetid: 06FD3940-D666-4C9E-BC3E-BBE481EF8012
ms.technology: xamarin-ios
author: davidortinau
ms.author: daortin
ms.date: 03/18/2017
ms.openlocfilehash: 90e14fdd81168563e105e62d9aefd81fdc5f0168
ms.sourcegitcommit: e27e29c14b783263e063baaa65d4eecb8dd31f57
ms.translationtype: HT
ms.contentlocale: ru-RU
ms.lasthandoff: 01/21/2021
ms.locfileid: "98628804"
---
# <a name="ios-build-mechanics"></a>Механизм сборки iOS

_В этом руководстве описано, как планировать приложения и использовать методы, которые можно применять для ускоренного создания сборок для всех конфигураций_.

Разработка эффективных приложений — это не просто написание работающего кода. Грамотно сконструированные приложения должны быть оптимизированы, чтобы сборка выполнялась быстрее, а исполняемые файлы занимали меньше места и работали эффективнее. Такая оптимизация улучшит взаимодействие с приложением не только для пользователя, но и для всех разработчиков, работающих над проектом. При работе с приложением очень важно часто выполнять замеры времени для всех операций. 

Всегда помните, что значения по умолчанию обеспечат хорошую скорость и безопасность, но не будут оптимальны для каждого случая. Кроме того, многие параметры замедляют или ускоряют цикл разработки для конкретных проектов. Например, удаление лишних элементов потребует дополнительного времени. Если сокращение объема будет небольшим, затраченное на удаление время не компенсируется более быстрым развертыванием. С другой стороны, иногда удаление лишних элементов позволят настолько существенно уменьшить приложение, что в целом развертывание ускоряется. Для разных проектов условия будут разными, и только тесты позволят определить оптимальный вариант.

Скорость сборки на Xamarin зависит от разных характеристик и возможностей компьютера, в том числе от скорости процессора, частоты шины, объема физической памяти, скорости работы жесткого диска, скорости сетевого подключения. Описание таких ограничений выходит за рамки данного документа, и мы оставляем их изучение разработчикам.

## <a name="timing-apps"></a>Замеры времени для приложений

# <a name="visual-studio-for-mac"></a>[Visual Studio для Mac](#tab/macos)

Чтобы включить вывод диагностики MSBuild в Visual Studio для Mac, выполните следующие действия:

1. Щелкните **Visual Studio для Mac > Параметры...**
2. В представлении дерева слева выберите **Проекты > Сборка**
3. На панели справа откройте раскрывающийся список детализации журнала и выберите вариант **Диагностика**:  [![Настройка детализации журнала](ios-build-mechanics-images/image2.png)](ios-build-mechanics-images/image2.png#lightbox)
4. Нажмите кнопку **ОК**.
5. Перезапустите Visual Studio для Mac.
6. Выполните очистку и перестройку пакета.
7. Просмотрите диагностический вывод на панели ошибок (Представление > Панели > Ошибки), нажав кнопку выходных данных сборки.

# <a name="visual-studio"></a>[Visual Studio](#tab/windows)

Чтобы включить вывод диагностики MSBuild в Visual Studio, выполните следующие действия:

1. Щелкните **Инструменты > Параметры...**
2. В представлении дерева слева выберите **Проекты и решения > Сборка и запуск**.
3. На панели справа в *раскрывающемся списке детализации выходных данных сборки MSBuild* выберите вариант **Диагностика**:  [![Настройка детализации для выходных данных сборки MSBuild](ios-build-mechanics-images/image2-vs.png)](ios-build-mechanics-images/image2-vs.png#lightbox)
4. Нажмите кнопку **ОК**.
5. Выполните очистку и перестройку пакета.
6. Данные диагностики появятся в области вывода.

-----

## <a name="timing-mtouch"></a>Замер времени для mtouch

Чтобы отобразить сведения о процессе сборки mtouch, передайте `--time --time` в качестве аргумента для mtouch на странице **Параметры проекта**. Результаты будут отображаться в выходных данных сборки, где их можно найти по имени задачи `MTouch`:

```csharp
Setup: 36 ms
Resolve References: 982 ms
Extracted native link info: 987 ms
...
Total time: 1554 ms
```

## <a name="connecting-from-visual-studio-with-build-host"></a>Подключение из Visual Studio к узлу сборки

Средства Xamarin технически могут выполняться на любом компьютере Mac, где можно запустить OS X 10.10 Yosemite или более поздней версии. Но возможности разработки и времена сборки могут существенно ухудшаться при плохой производительности Mac.

В отключенном режиме Visual Studio на Windows выполняет только этап компиляции C# и не пытается применять компоновку, компиляцию AOT, упаковку приложения в пакет _.app_ или подписывание пакета приложения. (Этап компиляции C# редко является узким местом для производительности.) Чтобы точно определить, какая часть конвейера сборки замедляет работу, попробуйте выполнить сборку непосредственно на узле сборки Mac в Visual Studio для Mac.

Кроме того, довольно часто причиной задержки может быть сетевое подключение между компьютером Windows и узлом сборки Mac. Это может быть вызвано физической проблемой в сети, скоростью беспроводного соединения или наличием перегруженной машины в цепочке между компьютерами (например, в службе Mac-in-the-cloud).

## <a name="simulator-tricks"></a>Советы при работе с эмулятором

При разработке приложений для мобильных устройств важно быстро развернуть код. В разных ситуациях и по разным причинам, например для ускорения работы или при отсутствии подходящего устройства, разработчики могут выбрать для развертывания предварительно настроенный симулятор или эмулятор. При предоставлении симулятора или эмулятора производителям средств для разработчиков приходится выбирать между скоростью и совместимостью. 

Симулятор Apple для разработки в iOS отдает приоритет скорости в ущерб совместимости, применяя менее строгую среду для выполнения кода. Такое снижение требований к среде позволяет Xamarin использовать для симулятора компилятор JIT (в отличие от [AOT](~/ios/internals/architecture.md), используемого на устройствах). Это означает, что сборка в машинный код выполняется во время выполнения. Поскольку Mac всегда намного быстрее, чем устройство, это повышает производительность.

Симулятор использует общее средство запуска приложений, позволяя использовать его повторно, тогда как на устройстве его приходится компилировать каждый раз заново.

Все вышеизложенные факторы учтены в следующем списке, который поможет вам разобраться в том, какие действия при сборке и развертывании приложений в симуляторе помогут оптимизировать производительность.

### <a name="tips"></a>Советы

- Для сборок 
  - Снимите флажок **Оптимизировать изображения PNG** в параметрах проекта. Эта оптимизация не нужна для сборок в симуляторе.
  - Для компоновщика выберите вариант **Не компоновать**. Компоновщик выполняется довольно долго, а значит его отключение ускоряет процесс.
  - Если вы отключите общее средство запуска приложений флажком `--nofastsim`, сборка симулятора будет работать намного медленнее. Уберите этот флажок, как только в нем отпадет необходимость.
  - Работа с собственными библиотеками проходит медленнее, поскольку в этом случае нельзя применить общее средство запуска в симуляторе. Это означает, что для каждой сборки нужно заново компилировать полный исполняемый файл для конкретного приложения.
- Для развертывания
  - Всегда оставляйте симулятор работать, если это возможно. На холодный запуск симулятора требуется до 12 секунд.
- Дополнительные советы
  - Старайтесь выбирать сборку, а не повторную сборку, поскольку второй вариант выполняет очистку перед сборкой. Эта очистка увеличивает время работы, поскольку она удаляет ссылки, которые можно использовать.
  - Воспользуйтесь тем, что симулятор не требует применять песочницу. Включение в проект больших ресурсов, таких как видео, вынуждает применять длительное копирование файлов при каждом запуске приложения в симуляторе. Старайтесь избегать таких затратных операций, например размещайте большие файлы в корневом каталоге и указывайте в приложении ссылки на них в виде полного пути к файлу.  
  - Если вы сомневаетесь, используйте флаг `--time --time` для оценки изменений

На снимке экрана ниже показано, как задавать эти параметры симулятора в параметрах iOS.

[![Снимок экрана: показаны параметры проекта, включая параметры "Поведение компоновщика", "Дополнительные аргументы mtouch" и "Оптимизировать изображения PNG".](ios-build-mechanics-images/image3.png)](ios-build-mechanics-images/image3.png#lightbox)

## <a name="device-tricks"></a>Рекомендации для устройства

Развертывание на устройстве выполняется так же, как и развертывание в симуляторе, поскольку симулятор представляет собой часть сборки, используемой для реального устройства iOS. Сборка для устройства требует больше дополнительных действий, но зато дает больше возможностей оптимизировать приложение.

### <a name="build-configurations"></a>Конфигурации сборки

При развертывании приложения iOS предоставляется несколько вариантов конфигурации сборки. Очень важно хорошо понимать каждую из этих конфигураций, чтобы знать, когда и чем будет полезна оптимизация.

- Отладка
  - Это основная конфигурация, которую следует постоянно использовать на этапе разработки приложения. Она выполняется максимально быстро.
- Выпуск
  - Сборки выпусков создают файлы, передаваемые пользователям, и здесь быстродействие имеет первостепенное значение. Совместно с конфигурацией выпуска можно использовать оптимизирующий компилятор LLVM и оптимизацию PNG-файлов.

Также важно понимать взаимосвязь между сборкой и развертыванием. Время развертывания напрямую зависит от размера приложения. Чем крупнее приложение, тем больше времени нужно для его развертывания. Уменьшая размер приложения, вы сможете уменьшить время развертывания.

Но одновременно с уменьшением размера приложения может снижаться и время сборки. Это связано с тем, что удаление кода из приложения занимает меньше времени, чем компиляция в машинный код тех фрагментов, которые не будут использоваться. Уменьшение объектных файлов ускоряет компоновку, а также позволяет создать исполняемый файл меньшего размера благодаря уменьшению числа создаваемых символов. Таким образом, снижение размера окупается дважды. По этой простой причине для всех сборок для устройства по умолчанию применяется вариант **Компоновать SDK**. 

> [!NOTE]
> Параметр **Компоновать SDK** может выглядеть в вашей среде разработки как "Компоновать только пакеты SDK" или "Компоновать только сборки SDK" и т. п.

### <a name="tips"></a>Советы

- Сборка: 
  - Сборка для одной архитектуры (например, ARM64) выполняется быстрее, чем сборка толстого двоичного файла (например, для ARMv7 и ARM64).
  - Избегайте оптимизации PNG-файлов на этапе отладки.
  - Попробуйте использовать компоновку для всех сборок. Оптимизируйте все сборки. 
  - Отключите создание отладочных символов с помощью `--dsym=false`. Но не забывайте, что их отключение означает, что в отчетах о сбоях символы будут создаваться только на том компьютере, где выполнялась сборка приложения, и только в том случае, если для приложения не удалялись лишние компоненты.

Вот список действий, которых следует избегать.

- Толстые двоичные файлы (для отладки). 
- Отключение компоновщика `--nolink`. 
- Отключение удаления. 
  - Символы `--nosymbolstrip`. 
  - IL (для выпуска) `--nostrip`.  

Дополнительные советы 

- Как и в симуляторе, старайтесь выбирать сборку вместо перестроения. 
  - Сборки AOT (объектные файлы) сохраняются в кэше сборок. 
- Отладочные построения занимают больше времени из-за применения символов и dsymutil, а также из-за большего размера файлов и, следовательно, увеличения времени на их загрузку. 
- Сборка выпуска по умолчанию удаляет IL из сборок. Это занимает очень мало времени и часто полностью оправдано благодаря снижению размера APP-файла для развертывания на устройстве.
- Старайтесь не развертывать большие статические файлы при каждой сборке (при отладке). 
  - Используйте UIFileSharingEnabled (info.plist). 
    - Ресурсы можно отправлять однократно. 
- Если вы сомневаетесь, используйте флаг `--time --time` для оценки изменений

На снимке экрана ниже показано, как задавать эти параметры симулятора в параметрах iOS.

[![Снимок экрана: показаны параметры проекта, включая параметры "Поведение компоновщика", "Поддерживаемые архитектуры" и другие.](ios-build-mechanics-images/image4.png)](ios-build-mechanics-images/image4.png#lightbox)

## <a name="using-the-linker"></a>Использование компоновщика

При сборке приложения mtouch использует для управляемого кода компоновщик, который удаляет код, не используемый приложением. Теоретически это уменьшает размер файла и ускоряет сборку. Дополнительные сведения о компоновщике см. в руководстве [по компоновке в iOS](~/ios/deploy-test/linker.md).

При использовании компоновщика учтите следующие аспекты.

- Если для устройства выбрать **Не компоновать**, сборка займет больше времени и создаст приложение большего размера. 
  - Apple отклоняет приложения, размер которых превышает установленное ограничение. В зависимости от `MinimumOSVersion` ограничение может быть всего 60 МБ. 
  - Сюда включается и исполняемый файл в машинном коде. 
  - Вариант "Не компоновать" работает быстрее при сборке для симулятора, поскольку в нем применяется JIT-компиляция (в отличие от AOT на устройстве).
- По умолчанию используется вариант "Компоновать SDK".
- Вариант "Компоновать все" иногда небезопасен, особенно если вы используете не только собственный код, а например NuGets или Components. Если вы откажетесь от компоновки сборок, весь код этих служб будет включен в ваше приложение, что может значительно увеличить его размер. 
  - Но если вы выберете **Компоновать все**, работа приложения может завершиться сбоем. Такой сценарий еще более вероятен, если оно использует внешние компоненты. Это связано с тем, что некоторые компоненты используют отражения для определенных типов.
  - Статический анализ несовместим с применением отражений. 

Вы можете применить [атрибут `[Preserve]`](~/ios/deploy-test/linker.md), чтобы сохранять нужные фрагменты кода в приложении. 

Если у вас нет доступа к исходному коду или код создается с помощью автоматических средств, изменение которых нежелательно, защиту от удаления можно обеспечить с помощью XML-файла с полным списком сохраняемых типов и членов. Создав такой файл, добавьте в параметры проекта флаг `--xml={file.name}.xml`, и тогда код будет обрабатываться так же, как если бы вы использовали атрибуты.

### <a name="partially-linking-applications"></a>Частичная компоновка приложений 

Вы можете применить для приложения частичную компоновку, чтобы оптимизировать время его сборки:

- Используйте `Link All`, чтобы пропустить некоторые сборки. 
  - Это приведет к некоторому увеличению размера приложения.
  - Для этого не нужен доступ к исходному коду.
  - Пример: `--linkall --linkskip=fieldserviceiOS`.

- Используйте вариант `Link SDK` и атрибут `[LinkerSafe]` для тех сборок, которые нужно сохранить. 
  - Для этого нужен доступ к исходному коду.
  - Так вы сообщите системе, что для сборки можно безопасно применять компоновку, и она будет обработана так же, как и Xamarin SDK.

### <a name="objective-c-bindings"></a>Привязки Objective-C 

- Применив для привязок атрибут `[Assembly: LinkerSafe]`, вы можете уменьшить время сборки и размер файла.

- SmartLink 
  - Выполняется для машинного кода. 
  - Используйте атрибут `[LinkWith (SmartLink=true)]`.
  - Это помогает компоновщику машинного кода удалять фрагменты из библиотеки, на которую вы указали ссылку. 
  - Обратите внимание, что в этом случае не будет работать динамическая подстановка символов. 

## <a name="summary"></a>Сводка

Из этого руководства вы узнали, как замерять время для приложения iOS и какие варианты настройки можно применить для разных конфигураций сборки и параметров проекта. 

<!-----
# Benchmarks

## Layer 1: building again after making modifications, but _without_ cleaning should be faster 

The app should build a bit more quickly if you have only made changes to a subset of the libraries and you do not clean the build before re-deploying. 

### Clean build time 
178 seconds 

### Build again (without cleaning) after making _no changes_ 
12.5 seconds 

### Build again (without cleaning) after changing 1 line in "ViewIOS/ImageResourcesHelper.cs" 
3 trials: 45 seconds, 43 seconds, 43 seconds 

### Build again (without cleaning) after changing 1 line in each of the following files 

- ViewIOS/ImageResourcesHelper.cs 
- Sales.Native.Core.Tools/UIComponents/ListView/IListView.cs 
- View.Models/Mailing/MailingModel.cs 

3 trials: 45 seconds, 45 seconds, 45 seconds 

### Build again (without cleaning) after changing 1 line in each of the following files 

- ViewIOS/ImageResourcesHelper.cs 
- Sales.Native.Core.Tools/UIComponents/ListView/IListView.cs 
- View.Models/Mailing/MailingModel.cs 
- Sales.Native.Core.IOS.Ext/ServiceInterfaces/AlertDialog/Dialog.cs 
- Sales.Native.Core.Tools.IOS.Ext/BaseViews/BaseNavigationViewController.cs 
- View.Common/Services/DataTransferResult.cs 

45 seconds 

## Layer 2: "app thinning" aka "device specific builds" 

The idea of "app thinning" is that the IDE will only build the 1 architecture needed for the specific device that you're deploying to (rather than _both_ 32-bit and 64-bit architectures). 

As of the latest "Xamarin 4" builds, you can now enable "app thinning" in Visual Studio via the "Project Options -> iOS Build -> Enable device-specific builds" setting. 

Or if you prefer you can achieve a similar result by changing the "Project Options -> iOS Build -> Advanced [tab] -> Supported architectures" to select just _one_ architecture (for example ARM64 if you are developing on a 64-bit device). 

(Caveat: I ran the following builds in Visual Studio for Mac on the Mac rather than on the command line.) 

### Clean build time without "device specific builds" 
177 seconds 

### Clean build time _with_ "device specific builds"  
2 trials: 106 seconds, 98 seconds 

### Build again (without cleaning) after changing 1 line in "ViewIOS/ImageResourcesHelper.cs" 
2 trials: 31 seconds, 31 seconds 

* * * 

## Using the same strategy, but explicitly setting "Supported architectures" to select ARM64 _only_ (rather than using "device specific builds") 

(These builds were again run on the command line using `xbuild`.) 

### Clean build time with "Supported architectures" set to ARM64 _only_ 
2 trials: 80 seconds, 91 seconds 

### Build again (without cleaning) after changing 1 line in "ViewIOS/ImageResourcesHelper.cs" 
2 trials: 26 seconds, 26 seconds 

[1] Mac system used for testing: MacBookAir5,2 

- 2.0 GHz Core i7 (I7-3667U) 

2 Cores with hyper-threading 

L2 Cache (per Core): 256 KB 
L3 Cache: 4 MB 

- Standard MacBook soldered-in solid-state storage 

- 8 GB RAM 
---->

## <a name="related-links"></a>Связанные ссылки

- [Запись блога](https://blog.xamarin.com/xamarin-ios-build-improvements/)
- [Компоновка в iOS](~/ios/deploy-test/linker.md)
- [Пользовательская конфигурация компоновщика](~/cross-platform/deploy-test/linker.md)
