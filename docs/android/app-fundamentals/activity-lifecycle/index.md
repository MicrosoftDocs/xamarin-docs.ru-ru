---
title: Жизненный цикл действия
description: Действия — это фундаментальный Стандартный блок приложений Android, который может существовать в нескольких разных состояниях. Жизненный цикл действия начинается с создания экземпляра и заканчивается на уничтожение и включает много состояний между. Когда действие изменяет состояние, вызывается соответствующий метод события жизненного цикла, уведомляющий о действии ожидающего изменения состояния и позволяя ему выполнить код для адаптации к этому изменению. В этой статье изучается жизненный цикл действий и объясняется ответственность за то, что действие в ходе каждого из этих изменений состояния является частью хорошо организованного надежного приложения.
ms.prod: xamarin
ms.assetid: 05B34788-F2D2-4347-B66B-40AFD7B1D167
ms.technology: xamarin-android
author: davidortinau
ms.author: daortin
ms.date: 02/28/2018
ms.openlocfilehash: 2472086c700a6b2a93a4a1a834d7a7d3e6e635ce
ms.sourcegitcommit: 8fa0cb9ccbc107d697aa5b9113a4e5d1e75d6eb9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/27/2020
ms.locfileid: "96303048"
---
# <a name="activity-lifecycle"></a>Жизненный цикл действия

_Действия — это фундаментальный Стандартный блок приложений Android, который может существовать в нескольких разных состояниях. Жизненный цикл действия начинается с создания экземпляра и заканчивается на уничтожение и включает много состояний между. Когда действие изменяет состояние, вызывается соответствующий метод события жизненного цикла, уведомляющий о действии ожидающего изменения состояния и позволяя ему выполнить код для адаптации к этому изменению. В этой статье изучается жизненный цикл действий и объясняется ответственность за то, что действие в ходе каждого из этих изменений состояния является частью хорошо организованного надежного приложения._

## <a name="activity-lifecycle-overview"></a>Общие сведения о жизненном цикле действия

Действия — это необычная концепция программирования, относящаяся к Android. В традиционной разработке приложений обычно используется статический метод Main, который выполняется для запуска приложения. Тем не менее, в Android используются разные элементы. Приложения Android можно запускать с помощью любого зарегистрированного действия в приложении. На практике большинство приложений будут иметь только определенное действие, указанное в качестве точки входа приложения. Однако если приложение аварийно завершает работу или завершается операционной системой, операционная система может попытаться перезапустить приложение на последнем открытом действии или в любом другом месте предыдущего стека действий.
Кроме того, операционная система может приостановить действия, когда они неактивны, и высвободить их в случае нехватки памяти. Следует тщательно учитывать необходимость в том, чтобы приложение было правильно восстанавливать свое состояние в случае перезапуска действия, особенно если это действие зависит от данных из предыдущих действий.

Жизненный цикл действия реализуется как коллекция методов, которые вызывает операционная система в течение всего жизненного цикла действия. Эти методы позволяют разработчикам реализовать функциональные возможности, необходимые для удовлетворения требований к состоянию и управлению ресурсами своих приложений.

Разработчику приложения очень важно анализировать требования каждого действия, чтобы определить, какие методы, предоставляемые жизненным циклом действия, должны быть реализованы. Невыполнение этого действия может привести к нестабильной работе приложения, сбоям, чрезмерному повышению ресурсов и, возможно, даже к базовой нестабильной работе ОС.

В этой главе подробно рассматривается жизненный цикл действия, включая:

- Состояния действий
- Методы жизненного цикла
- Сохранение состояния приложения

В этом разделе также содержится [Пошаговое руководство](~/android/app-fundamentals/activity-lifecycle/saving-state.md) , в котором содержатся практические примеры эффективного сохранения состояния во время жизненного цикла действия. В конце этой главы вы получите представление о жизненном цикле действий и о том, как его поддерживать в приложении Android.

## <a name="activity-lifecycle"></a>Жизненный цикл действия

Жизненный цикл действия Android состоит из коллекции методов, предоставляемых в классе действия, которые предоставляют разработчику инфраструктуру управления ресурсами. Эта платформа позволяет разработчикам удовлетворить уникальные требования к управлению состоянием каждого действия в приложении и надлежащим образом обрабатывает управление ресурсами.

### <a name="activity-states"></a>Состояния действий

Действия единолично операционной системы Android в зависимости от их состояния. Это помогает Android выявление действий, которые больше не используются, что позволяет операционной системе высвободить память и ресурсы. На следующей схеме показаны состояния, через которые действие может пройти в течение своего времени существования:

[![Схема состояний действий](images/image1-sml.png)](images/image1.png#lightbox)

Эти состояния можно разбить на четыре основные группы следующим образом:

1. *Активно или работает* &ndash; Действия считаются активными или выполняются, если они находятся на переднем плане, также называемой верхней частью стека действий. Это действие считается самым высоким приоритетом в Android, поэтому операционная система будет уничтожена только операционной системой в экстремальных ситуациях, например если действие пытается использовать больше памяти, чем доступно на устройстве, так как это может привести к тому, что пользовательский интерфейс перестанет отвечать на запросы.

1. *Приостановлено* &ndash; Когда устройство переходит в спящий режим или действие по-прежнему отображается, но частично скрыто новым, неполным или прозрачным действием, действие считается приостановленным. Приостановленные действия по-прежнему действуют, то есть сохраняют все сведения о состоянии и члене и остаются присоединенными к диспетчеру окон. Это считается вторым действием с наивысшим приоритетом в Android и, таким образом, будет уничтожено только операционной системой, если завершение этого действия будет удовлетворять требованиям к ресурсам, необходимым для обеспечения стабильного и быстрого реагирования активного и работающего действия.

1. *Остановлено/обработано в фоновом режиме* &ndash; Действия, которые полностью скрыты другим действием, считаются остановленными или в фоновом режиме.
    Остановленные действия по-прежнему пытаются сохранить сведения о состоянии и члене до тех пор, пока остановленные действия считаются самым низким приоритетом трех состояний, и, таким образом, ОС будет сначала прерывать действия в этом состоянии, чтобы удовлетворить требования к ресурсам для более высоких приоритетных действий.

1. *Перезапущено* &ndash; Действие, которое находится в любом месте, может быть приостановлено в течение жизненного цикла, чтобы оно было удалено из памяти Android. Если пользователь вернется к действию, его необходимо перезапустить, восстановить в ранее сохраненное состояние, а затем показать пользователю.

### <a name="activity-re-creation-in-response-to-configuration-changes"></a>Re-Creation действий в ответ на изменения конфигурации

Чтобы сделать их более сложными, Android создает еще один гаечного ключа в сочетании, именуемом изменениями конфигурации. Изменения конфигурации — это циклы быстрого удаления и повторного создания действий, происходящих при изменении конфигурации действия. Например, если устройство [поворачивается](~/android/app-fundamentals/handling-rotation.md) (а действие должно быть перестроено в альбомной или портретной ориентации), при отображении клавиатуры (при этом действие имеет возможность изменить размер) или когда устройство помещается в закрепление.

Изменения конфигурации по-прежнему вызывают те же изменения состояния действий, которые произошли бы во время остановки и перезапуска действия. Однако, чтобы убедиться, что приложение реагирует на запросы и хорошо работает во время изменений конфигурации, важно, чтобы они обрабатывались как можно быстрее. По этой причине в Android имеется специальный API, который можно использовать для сохранения состояния во время изменений конфигурации.
Это будет рассмотрено далее в [состоянии управления в течение всего жизненного цикла](~/android/app-fundamentals/activity-lifecycle/index.md#Managing_State_Throughout_the_Lifecycle) .

### <a name="activity-lifecycle-methods"></a>Методы жизненного цикла действия

Пакет SDK для Android и, по расширению, платформа Xamarin. Android предоставляет мощную модель для управления состоянием действий в приложении. Когда состояние действия изменяется, действие получает уведомления операционной системы, которое вызывает определенные методы для этого действия. На следующей схеме показаны эти методы в зависимости от жизненного цикла действия.

[![Блок-схема жизненного цикла действия](images/image2-sml.png)](images/image2.png#lightbox)

Разработчик может управлять изменениями состояния, переопределяя эти методы в рамках действия. Однако важно отметить, что все методы жизненного цикла вызываются в потоке пользовательского интерфейса и блокируют выполнение следующей части работы пользовательского интерфейса, например скрытие текущего действия, отображение нового действия и т. д. Таким образом, код в этих методах должен быть как можно более кратким, чтобы приложение было хорошо работать. Все длительно выполняемые задачи должны выполняться в фоновом потоке.

Давайте рассмотрим каждый из этих методов жизненного цикла и их использование:

#### <a name="oncreate"></a>OnCreate

[OnCreate](xref:Android.App.Activity.OnCreate*) — это первый метод, который вызывается при создании действия.
`OnCreate` всегда переопределяется для выполнения инициализации запуска, которая может потребоваться для действия, например:

- Создание представлений
- Инициализация переменных
- Привязка статических данных к спискам

`OnCreate` принимает параметр [пакета](xref:Android.OS.Bundle) , который является словарем для хранения и передачи сведений о состоянии и объектов между действиями, если пакет не равен null, это указывает на то, что действие перезапускается и должно восстановить его состояние из предыдущего экземпляра. В следующем коде показано, как извлечь значения из пакета:

```csharp
protected override void OnCreate(Bundle bundle)
{
   base.OnCreate(bundle);

   string intentString;
   bool intentBool;

   if (bundle != null)
   {
      intentString = bundle.GetString("myString");
      intentBool = bundle.GetBoolean("myBool");
   }

   // Set our view from the "main" layout resource
   SetContentView(Resource.Layout.Main);
}
```

`OnCreate`По завершении Android выполнит вызов `OnStart` .

#### <a name="onstart"></a>OnStart

[OnStart](xref:Android.App.Activity.OnStart) всегда вызывается системой после `OnCreate` завершения работы. Действия могут переопределять этот метод, если им нужно выполнять определенные задачи до того, как действие станет видимым, например обновлять текущие значения представлений в рамках действия. Android будет вызываться `OnResume` сразу после этого метода.

#### <a name="onresume"></a>Onresume

Система вызывает [Onresume](xref:Android.App.Activity.OnResume) , когда действие готово к началу взаимодействия с пользователем.
Действия должны переопределять этот метод для выполнения таких задач, как:

- Увеличение частоты кадров (типичная задача при разработке игр)
- Запуск анимации
- Прослушивание обновлений GPS
- Отображение всех соответствующих предупреждений или диалогов
- Подсоединить внешние обработчики событий

Например, в следующем фрагменте кода показано, как инициализировать камеру:

```csharp
public void OnResume()
{
    base.OnResume(); // Always call the superclass first.

    if (_camera==null)
    {
        // Do camera initializations here
    }
}
```

`OnResume` важно, так как любая операция, выполняемая в `OnPause` , должна быть отменена в `OnResume` , так как это единственный метод жизненного цикла, который гарантированно будет выполняться после `OnPause` возврата действия в жизнь.

#### <a name="onpause"></a>Приостановка

[OnPause](xref:Android.App.Activity.OnPause) вызывается, когда система собирается перевести действие в фоновый режим или когда действие становится частично незаметной. Действия должны переопределять этот метод, если необходимо:

- Зафиксировать несохраненные изменения в постоянных данных

- Удаление или очистка других объектов, использующих ресурсы

- Снижение частоты кадров и приостановка анимации

- Отмените регистрацию обработчиков внешних событий или обработчиков уведомлений (т. е. тех, которые привязаны к службе). Это необходимо сделать для предотвращения утечек памяти действий.

- Аналогично, если действие отображает какие бы то ни было диалоговые окна или оповещения, оно должно быть очищено с помощью `.Dismiss()` метода.

Например, в следующем фрагменте кода будет освобождена камера, так как действие не может использовать его при приостановке:

```csharp
public void OnPause()
{
    base.OnPause(); // Always call the superclass first

    // Release the camera as other activities might need it
    if (_camera != null)
    {
        _camera.Release();
        _camera = null;
    }
}
```

Существует два возможных метода жизненного цикла, которые будут вызываться после `OnPause` :

1. `OnResume` будет вызываться, если действие должно возвращаться на передний план.
1. `OnStop` будет вызываться, если действие помещается в фоновом режиме.

#### <a name="onstop"></a>OnStop

[OnStop](xref:Android.App.Activity.OnStop) вызывается, когда действие больше не видимо для пользователя. Это происходит, когда происходит одно из следующих событий:

- Запускается новое действие, которое охватывает это действие.
- Существующее действие переносится на передний план.
- Действие уничтожается.

`OnStop` не всегда может вызываться в ситуациях нехватки памяти, например, когда Android недоступен для ресурсов и не может правильно запланировать действие. По этой причине лучше не полагаться на `OnStop` вызов метода при подготовке действия к уничтожению. Следующие методы жизненного цикла, которые могут быть вызваны после этого, будут выполняться `OnDestroy` , если действие выходит из эксплуатации, или `OnRestart` Если действие возвращается к взаимодействию с пользователем.

#### <a name="ondestroy"></a>OnDestroy

[OnDestroy](xref:Android.App.Activity.OnDestroy) — это окончательный метод, который вызывается для экземпляра действия до его уничтожения и полного удаления из памяти. В экстремальных ситуациях Android может прекратить процесс приложения, в котором размещается действие, что приведет к невозможности `OnDestroy` его вызова. Большинство действий не реализуют этот метод, так как большинство методов очистки и завершения работы выполняются в `OnPause` `OnStop` методах и. `OnDestroy`Метод обычно переопределяется для очистки длительно выполняемых задач, которые могут привести к утечке ресурсов. Например, это могут быть фоновые потоки, которые были запущены в `OnCreate` .

После уничтожения действия методы жизненного цикла не будут вызываться.

#### <a name="onrestart"></a>Restart

[Restart](xref:Android.App.Activity.OnRestart) вызывается после того, как действие было остановлено, прежде чем оно будет запущено снова. Хорошим примером этого может быть то, что пользователь нажмет кнопку «домой» при выполнении действия в приложении. Когда это происходит, `OnPause` а затем `OnStop` вызываются методы, и действие перемещается в фон, но не уничтожается. Если пользователь восстанавливает приложение с помощью диспетчера задач или аналогичного приложения, то Android вызывает `OnRestart` метод действия.

Не существует общих правил для того, какой тип логики следует реализовать в `OnRestart` . Это происходит потому `OnStart` , что всегда вызывается, независимо от того, создается или перезапускается действие, поэтому все ресурсы, необходимые для действия, должны инициализироваться в `OnStart` , а не `OnRestart` .

Следующий метод жизненного цикла, вызываемый после `OnRestart` , будет иметь значение `OnStart` .

### <a name="back-vs-home"></a>Обратная и домашняя

У многих устройств Android есть две отдельные кнопки: кнопка "назад" и кнопка "домой". Пример можно увидеть на следующем снимке экрана Android 4.0.3:

[![Кнопки "назад" и "домой"](images/image4-sml.png)](images/image4.png#lightbox)

Существует небольшая разница между двумя кнопками, хотя они имеют одинаковый результат размещения приложения в фоновом режиме. Когда пользователь нажимает кнопку "назад", он сообщает Android о том, что они выполняются с действием. Android приведет к уничтожению действия. В противоположность этому, когда пользователь нажимает кнопку "домой", действие просто помещается в фоновое &ndash; Android, не будет прерывать действие.

<a name="Managing_State_Throughout_the_Lifecycle"></a>

## <a name="managing-state-throughout-the-lifecycle"></a>Управление состоянием в течение жизненного цикла

Когда действие остановлено или уничтожено, система предоставляет возможность сохранить состояние действия для последующего переброски.
Это сохраненное состояние называется состоянием экземпляра. Android предоставляет три варианта хранения состояния экземпляра во время жизненного цикла действия:

1. Хранение примитивных значений в `Dictionary` виде [пакета](xref:Android.OS.Bundle) , который Android будет использовать для сохранения состояния.

1. Создание пользовательского класса, который будет содержать сложные значения, такие как точечные рисунки. Android будет использовать этот пользовательский класс для сохранения состояния.

1. Обход жизненного цикла изменения конфигурации и предположение полной ответственности за поддержание состояния в действии.

В этом руководстве рассматриваются два первых варианта.

### <a name="bundle-state"></a>Состояние пакета

Основным вариантом сохранения состояния экземпляра является использование объекта словаря ключей и значений, известного как [пакет](xref:Android.OS.Bundle).
Помните, что при создании действия `OnCreate` метод передает пакет в качестве параметра, этот пакет можно использовать для восстановления состояния экземпляра. Не рекомендуется использовать пакет для более сложных данных, которые не будут быстро или легко сериализоваться в пары "ключ-значение" (например, точечные рисунки); Вместо этого он должен использоваться для простых значений, таких как строки.

Действие предоставляет методы, помогающие сохранить и извлечь состояние экземпляра в пакете:

- [Онсавеинстанцестате](xref:Android.App.Activity.OnSaveInstanceState*) &ndash; Это вызывается Android при уничтожении действия. Действия могут реализовать этот метод, если нужно сохранить все элементы состояния ключа или значения.

- [Онрестореинстанцестате](xref:Android.App.Activity.OnRestoreInstanceState*) &ndash; Этот метод вызывается после завершения `OnCreate` метода и предоставляет еще одну возможность восстановить свое состояние после завершения инициализации действия.

На следующей схеме показано, как используются эти методы.

[![Блок-схема состояний набора](images/image3-sml.png)](images/image3.png#lightbox)

#### <a name="onsaveinstancestate"></a>онсавеинстанцестате

[Онсавеинстанцестате](xref:Android.App.Activity.OnSaveInstanceState*) будет вызываться при остановке действия. Он получит параметр пакета, в котором действие может сохранить свое состояние в. При изменении конфигурации на устройстве действие может использовать `Bundle` объект, переданный в, чтобы сохранить состояние действия путем переопределения `OnSaveInstanceState` . Рассмотрим следующий пример кода:

```csharp
int c;

protected override void OnCreate (Bundle bundle)
{
  base.OnCreate (bundle);

  this.SetContentView (Resource.Layout.SimpleStateView);

  var output = this.FindViewById<TextView> (Resource.Id.outputText);

  if (bundle != null) {
    c = bundle.GetInt ("counter", -1);
  } else {
    c = -1;
  }

  output.Text = c.ToString ();

  var incrementCounter = this.FindViewById<Button> (Resource.Id.incrementCounter);

  incrementCounter.Click += (s,e) => {
    output.Text = (++c).ToString();
  };
}
```

Приведенный выше код увеличивает целое число с именем `c` при нажатии кнопки с именем `incrementCounter` и отображает результат в виде `TextView` именованного объекта `output` . При изменении конфигурации (например, при смене устройства), приведенный выше код потерял бы значение `c` , так как это было `bundle` бы `null` , как показано на рисунке ниже:

[![Отображение не показывает предыдущее значение](images/07-sml.png)](images/07.png#lightbox)

Чтобы сохранить значение `c` в этом примере, действие может переопределить `OnSaveInstanceState` , сохранив значение в пакете, как показано ниже:

```csharp
protected override void OnSaveInstanceState (Bundle outState)
{
  outState.PutInt ("counter", c);
  base.OnSaveInstanceState (outState);
}
```

Теперь, когда устройство поворачивается на новую ориентацию, целое число сохраняется в пакете и извлекается со строкой:

```csharp
c = bundle.GetInt ("counter", -1);
```

> [!NOTE]
> Важно всегда вызывать базовую реализацию для `OnSaveInstanceState` того, чтобы можно было сохранить состояние иерархии представления.

##### <a name="view-state"></a>Состояние представления

Переопределение `OnSaveInstanceState` является подходящим механизмом для сохранения временных данных в рамках действия по изменению ориентации, например счетчика в приведенном выше примере. Однако реализация по умолчанию `OnSaveInstanceState` будет сохранять временные данные в пользовательском интерфейсе для каждого представления, при условии, что каждому представлению назначен идентификатор. Например, предположим, что приложение содержит `EditText` элемент, определенный в XML следующим образом:

```xml
<EditText android:id="@+id/myText"
  android:layout_width="fill_parent"
  android:layout_height="wrap_content"/>
```

Поскольку `EditText` элемент управления `id` назначен, когда пользователь вводит некоторые данные и поворачивает устройство, данные по-прежнему отображаются, как показано ниже:

[![Данные сохраняются в альбомном режиме](images/08-sml.png)](images/08.png#lightbox)

#### <a name="onrestoreinstancestate"></a>онрестореинстанцестате

[Онрестореинстанцестате](xref:Android.App.Activity.OnRestoreInstanceState*) будет вызван после `OnStart` . Она предоставляет действию возможность восстановления любого состояния, которое ранее было сохранено в пакете во время предыдущего `OnSaveInstanceState` . Однако это тот же пакет, который предоставляется для `OnCreate` .

В следующем коде показано, как можно восстановить состояние в `OnRestoreInstanceState` :

```csharp
protected override void OnRestoreInstanceState(Bundle savedState)
{
    base.OnRestoreSaveInstanceState(savedState);
    var myString = savedState.GetString("myString");
    var myBool = savedState.GetBoolean("myBool");
}
```

Этот метод существует для обеспечения некоторой гибкости при восстановлении состояния. Иногда лучше ожидать завершения всех инициализаций перед восстановлением состояния экземпляра. Кроме того, подклассу существующего действия может потребоваться восстановить только определенные значения из состояния экземпляра. Во многих случаях переопределение не требуется `OnRestoreInstanceState` , так как большинство действий может восстановить состояние с помощью пакета, предоставленного для `OnCreate` .

Пример сохранения состояния с помощью `Bundle` см. в [пошаговом руководстве — сохранение состояния действия](saving-state.md).

#### <a name="bundle-limitations"></a>Ограничения пакета

Несмотря `OnSaveInstanceState` на то, что позволяет легко сохранять временные данные, у них есть некоторые ограничения.

- Он не вызывается во всех случаях. Например, если нажать клавишу **Home** или **назад** для выхода из действия, вызов не будет выполнен `OnSaveInstanceState` .

- Пакет, переданный в, `OnSaveInstanceState` не предназначен для больших объектов, таких как изображения. В случае с большими объектами рекомендуется сохранить объект из [онретаиннонконфигуратионинстанце](xref:Android.App.Activity.OnRetainNonConfigurationInstance) , как описано ниже.

- Данные, сохраненные с помощью пакета, сериализуются, что может привести к задержкам.

Состояние пакета полезно для простых данных, которые не используют много памяти, в то время как *данные экземпляра, не относящиеся к конфигурации* , полезны для более сложных данных или данных, которые извлекаются дорого, например из вызова веб-службы или сложного запроса к базе данных. Данные экземпляра, не относящиеся к конфигурации, сохраняются в объекте по мере необходимости. В следующем разделе представлен `OnRetainNonConfigurationInstance` способ сохранения более сложных типов данных с помощью изменений конфигурации.

### <a name="persisting-complex-data"></a>Сохранение сложных данных

Кроме сохранения данных в пакете, Android также поддерживает сохранение данных путем переопределения [онретаиннонконфигуратионинстанце](xref:Android.App.Activity.OnRetainNonConfigurationInstance) и возврата экземпляра `Java.Lang.Object` , содержащего данные для сохранения. Существует два основных преимущества использования `OnRetainNonConfigurationInstance` для сохранения состояния:

- Объект, возвращаемый из `OnRetainNonConfigurationInstance` , хорошо работает с большими, более сложными типами данных, так как память удерживает этот объект.

- `OnRetainNonConfigurationInstance`Метод вызывается по запросу и только при необходимости. Это более экономично, чем использование кэша вручную.

Использование подходит `OnRetainNonConfigurationInstance` для сценариев, где дорогостоящее извлечение данных происходит несколько раз, например в вызовах веб-служб. Например, рассмотрим следующий код, который выполняет поиск в Twitter:

```csharp
public class NonConfigInstanceActivity : ListActivity
{
  protected override void OnCreate (Bundle bundle)
  {
    base.OnCreate (bundle);
    SearchTwitter ("xamarin");
  }

  public void SearchTwitter (string text)
  {
    string searchUrl = String.Format("http://search.twitter.com/search.json?" + "q={0}&rpp=10&include_entities=false&" + "result_type=mixed", text);

    var httpReq = (HttpWebRequest)HttpWebRequest.Create (new Uri (searchUrl));
    httpReq.BeginGetResponse (new AsyncCallback (ResponseCallback), httpReq);
  }

  void ResponseCallback (IAsyncResult ar)
  {
    var httpReq = (HttpWebRequest)ar.AsyncState;

    using (var httpRes = (HttpWebResponse)httpReq.EndGetResponse (ar)) {
      ParseResults (httpRes);
    }
  }

  void ParseResults (HttpWebResponse httpRes)
  {
    var s = httpRes.GetResponseStream ();
    var j = (JsonObject)JsonObject.Load (s);

    var results = (from result in (JsonArray)j ["results"] let jResult = result as JsonObject select jResult ["text"].ToString ()).ToArray ();

    RunOnUiThread (() => {
      PopulateTweetList (results);
    });
  }

  void PopulateTweetList (string[] results)
  {
    ListAdapter = new ArrayAdapter<string> (this, Resource.Layout.ItemView, results);
  }
}
```

Этот код извлекает результаты из веб-формата в формате JSON, анализирует их, а затем представляет результаты в списке, как показано на следующем снимке экрана:

[![Результаты, отображаемые на экране](images/06-sml.png)](images/06.png#lightbox)

При изменении конфигурации (например, при смене устройства) код повторяет процесс. Чтобы повторно использовать полученные ранее результаты и не вызывали лишних, избыточных сетевых вызовов, мы можем использовать `OnRetainNonconfigurationInstance` для сохранения результатов, как показано ниже:

```csharp
public class NonConfigInstanceActivity : ListActivity
{
  TweetListWrapper _savedInstance;

  protected override void OnCreate (Bundle bundle)
  {
    base.OnCreate (bundle);

    var tweetsWrapper = LastNonConfigurationInstance as TweetListWrapper;

    if (tweetsWrapper != null) {
      PopulateTweetList (tweetsWrapper.Tweets);
    } else {
      SearchTwitter ("xamarin");
    }

    public override Java.Lang.Object OnRetainNonConfigurationInstance ()
    {
      base.OnRetainNonConfigurationInstance ();
      return _savedInstance;
    }

    ...

    void PopulateTweetList (string[] results)
    {
      ListAdapter = new ArrayAdapter<string> (this, Resource.Layout.ItemView, results);
      _savedInstance = new TweetListWrapper{Tweets=results};
    }
}
```

Теперь при вращении устройства исходные результаты извлекаются из `LastNonConfiguartionInstance` Свойства. В этом примере результаты состоят из `string[]` содержащих твитов. Поскольку `OnRetainNonConfigurationInstance` требует, чтобы `Java.Lang.Object` возвращался, объект `string[]` упаковывается в класс, который подклассы `Java.Lang.Object` , как показано ниже:

```csharp
class TweetListWrapper : Java.Lang.Object
{
  public string[] Tweets { get; set; }
}
```

Например, попытка использовать объект, `TextView` возвращенный из, `OnRetainNonConfigurationInstance` приведет к утечке действия, как показано в следующем коде:

```csharp
TextView _textView;

protected override void OnCreate (Bundle bundle)
{
  base.OnCreate (bundle);

  var tv = LastNonConfigurationInstance as TextViewWrapper;

  if(tv != null) {
    _textView = tv;
    var parent = _textView.Parent as FrameLayout;
    parent.RemoveView(_textView);
  } else {
    _textView = new TextView (this);
    _textView.Text = "This will leak.";
  }

  SetContentView (_textView);
}

public override Java.Lang.Object OnRetainNonConfigurationInstance ()
{
  base.OnRetainNonConfigurationInstance ();
  return _textView;
}
```

В этом разделе мы узнали, как сохранять простые данные о состоянии с помощью `Bundle` и сохранять более сложные типы данных с помощью `OnRetainNonConfigurationInstance` .

## <a name="summary"></a>Сводка

Жизненный цикл действий Android предоставляет мощную платформу для управления состоянием действий в приложении, но может быть непростой для понимания и реализации. В этой главе представлены различные состояния, на которые может пройти действие во время его существования, а также методы жизненного цикла, связанные с этими состояниями. Затем в каждом из этих методов было указано, какой тип логики следует выполнять.

## <a name="related-links"></a>Связанные ссылки

- [Обработка поворота](~/android/app-fundamentals/handling-rotation.md)
- [Действие Android](xref:Android.App.Activity)
