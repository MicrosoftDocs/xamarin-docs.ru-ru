---
title: Модульное тестирование корпоративных приложений
description: В этой главе объясняется, как выполняется модульное тестирование в мобильном приложении eShopOnContainers.
ms.prod: xamarin
ms.assetid: 4af82e52-f99b-4cad-b278-1745f190c240
ms.technology: xamarin-forms
author: davidbritch
ms.author: dabritch
ms.date: 08/07/2017
no-loc:
- Xamarin.Forms
- Xamarin.Essentials
ms.openlocfilehash: a05de34089fdf6ad90740067b88edea0b62f55a7
ms.sourcegitcommit: 32d2476a5f9016baa231b7471c88c1d4ccc08eb8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/18/2020
ms.locfileid: "84134658"
---
# <a name="unit-testing-enterprise-apps"></a>Модульное тестирование корпоративных приложений

Мобильные приложения имеют уникальные проблемы, которые не должны беспокоиться о приложениях для настольных систем и веб-приложений. Мобильные пользователи будут использовать разные устройства, сетевые подключения, доступность служб и ряд других факторов. Поэтому необходимо тестировать мобильные приложения, так как они будут использоваться в реальном мире для повышения качества, надежности и производительности. Существует много типов тестирования, которые следует выполнить в приложении, включая модульное тестирование, тестирование интеграции и тестирование пользовательского интерфейса, при котором модульное тестирование является наиболее распространенной формой тестирования.

Модульный тест принимает небольшую единицу приложения, обычно метод, изолирует его от оставшейся части кода и проверяет, правильно ли он работает. Его целью является проверка того, что каждая единица функциональности работает должным образом, чтобы ошибки не распространялись в течение всего приложения. Обнаружение ошибки в том, что она происходит, более эффективна, что повлияет на последствия ошибки косвенно на дополнительный момент сбоя.

Модульное тестирование оказывает наибольшее воздействие на качество кода, если оно является неотъемлемой частью рабочего процесса разработки программного обеспечения. Сразу же после написания метода необходимо написать модульные тесты, которые проверяют поведение метода в ответ на стандартные, границы и неправильные варианты входных данных, а также проверяют любые явные или неявные предположения, выполняемые кодом. Кроме того, при разработке на основе тестирования модульные тесты записываются перед кодом. В этом сценарии модульные тесты действуют как документация по проектированию и функциональные спецификации.

> [!NOTE]
> Модульные тесты очень эффективны по сравнению с регрессией, то есть к функциональным возможностям, которые использовались для работы, но были заблокированы при сбое обновления.

Модульные тесты обычно используют шаблон компоновки-акт-Assert:

- Раздел « *Размещение* » метода модульного теста инициализирует объекты и задает значение данных, передаваемых в тестируемый метод.
- В разделе " *акт* " вызывается тестируемый метод с необходимыми аргументами.
- В разделе *Assert* проверяется, правильно ли выполняется действие тестируемого метода.

После этого шаблона гарантируется, что модульные тесты будут доступны для чтения и последовательной совместимости.

## <a name="dependency-injection-and-unit-testing"></a>Внедрение зависимостей и модульное тестирование

Одной из причин внедрения слабо связанных архитектур является то, что она упрощает модульное тестирование. Один из типов, зарегистрированных с помощью Autofac, — это `OrderService` класс. В следующем примере кода показана структура этого класса:

```csharp
public class OrderDetailViewModel : ViewModelBase  
{  
    private IOrderService _ordersService;  

    public OrderDetailViewModel(IOrderService ordersService)  
    {  
        _ordersService = ordersService;  
    }  
    ...  
}
```

`OrderDetailViewModel`Класс зависит от `IOrderService` типа, который разрешается контейнером при создании `OrderDetailViewModel` объекта. Однако вместо того, чтобы создавать `OrderService` объект для модульного тестирования `OrderDetailViewModel` класса, замените `OrderService` объект на макет для целей тестов. Эта связь показана на рис. 10-1.

![](unit-testing-images/unittesting.png "Classes that implement the IOrderService interface")

**Рис. 10-1.** Классы, реализующие интерфейс Иордерсервице

Такой подход позволяет `OrderService` передавать объект в `OrderDetailViewModel` класс во время выполнения, а в интересах тестирования он позволяет `OrderMockService` передавать класс в `OrderDetailViewModel` класс во время тестирования. Основное преимущество этого подхода заключается в том, что он позволяет выполнять модульные тесты без использования неудобных ресурсов, таких как веб-службы или базы данных.

## <a name="testing-mvvm-applications"></a>Тестирование приложений MVVM

Тестирование моделей и моделей представлений из приложений MVVM идентично тестированию любых других классов, а также использование одних и тех же средств и методик, как модульное тестирование и макетирование. Однако существуют некоторые закономерности, типичные для моделирования и просмотра классов моделей, которые могут воспользоваться преимуществами определенных методов модульного тестирования.

> [!TIP]
> Протестируйте одну вещь с каждым модульным тестом. Не рекомендуется делать модульный тест более чем одним аспектом поведения единицы. Это ведет к тестам, которые трудно читать и обновлять. Это также может привести к путанице при интерпретации сбоя.

Мобильное приложение eShopOnContainers использует [xUnit](https://xunit.github.io/) для выполнения модульного тестирования, которое поддерживает два различных типа модульных тестов:

- Факты — это тесты, всегда имеющие значение true, которые проверяют инвариантные условия.
- Теории — это тесты, которые имеют значение только для определенного набора данных.

Модульные тесты, включенные в мобильное приложение eShopOnContainers, — это тесты фактов, поэтому каждый метод модульного тестирования снабжен `[Fact]` атрибутом.

> [!NOTE]
> тесты xUnit выполняются средством запуска тестов. Чтобы выполнить тестовое средство, запустите проект eShopOnContainers. сообщение TestRunner для требуемой платформы.

### <a name="testing-asynchronous-functionality"></a>Тестирование асинхронных функций

При реализации шаблона MVVM Просмотр моделей обычно вызывает операции со службами, как правило, асинхронно. Тесты для кода, который вызывает эти операции, обычно используют макеты как замены для фактических служб. В следующем примере кода показано тестирование асинхронных функций путем передачи макета службы в модель представления:

```csharp
[Fact]  
public async Task OrderPropertyIsNotNullAfterViewModelInitializationTest()  
{  
    var orderService = new OrderMockService();  
    var orderViewModel = new OrderDetailViewModel(orderService);  

    var order = await orderService.GetOrderAsync(1, GlobalSetting.Instance.AuthToken);  
    await orderViewModel.InitializeAsync(order);  

    Assert.NotNull(orderViewModel.Order);  
}
```

Этот модульный тест проверяет, что `Order` свойство `OrderDetailViewModel` экземпляра будет иметь значение после `InitializeAsync` вызова метода. `InitializeAsync`Метод вызывается при переходе к соответствующему представлению модели представления. Дополнительные сведения о навигации см. в разделе [Навигация](~/xamarin-forms/enterprise-application-patterns/navigation.md).

При `OrderDetailViewModel` создании экземпляра он принимает в `OrderService` качестве аргумента экземпляр. Однако `OrderService` получает данные из веб-службы. Таким образом, `OrderMockService` экземпляр, являющийся макетом `OrderService` класса, указывается в качестве аргумента для `OrderDetailViewModel` конструктора. Затем при `InitializeAsync` вызове метода модели представления, который вызывает `IOrderService` операции, извлекаются Макетные данные, а не связь с веб-службой.

### <a name="testing-inotifypropertychanged-implementations"></a>Тестирование реализаций INotifyPropertyChanged

Реализация `INotifyPropertyChanged` интерфейса позволяет представлениям реагировать на изменения, происходящие из моделей и моделей представления. Эти изменения не ограничиваются данными, отображаемыми в элементах управления — они также используются для управления представлением, например для представления состояний моделей, которые приводят к запуску анимации или отключению элементов управления.

Свойства, которые могут быть обновлены непосредственно модульным тестом, можно проверить, присоединив обработчик событий к `PropertyChanged` событию и проверив, вызвано ли событие после установки нового значения для свойства. В следующем примере кода показан такой тест:

```csharp
[Fact]  
public async Task SettingOrderPropertyShouldRaisePropertyChanged()  
{  
    bool invoked = false;  
    var orderService = new OrderMockService();  
    var orderViewModel = new OrderDetailViewModel(orderService);  

    orderViewModel.PropertyChanged += (sender, e) =>  
    {  
        if (e.PropertyName.Equals("Order"))  
            invoked = true;  
    };  
    var order = await orderService.GetOrderAsync(1, GlobalSetting.Instance.AuthToken);  
    await orderViewModel.InitializeAsync(order);  

    Assert.True(invoked);  
}
```

Этот модульный тест вызывает `InitializeAsync` метод `OrderViewModel` класса, который вызывает `Order` обновление его свойства. Модульный тест будет пройден при условии, что `PropertyChanged` событие вызывается для `Order` Свойства.

### <a name="testing-message-based-communication"></a>Тестирование связи на основе сообщений

Просмотр моделей, использующих [`MessagingCenter`](xref:Xamarin.Forms.MessagingCenter) класс для обмена данными между слабо связанными классами, может быть модульным тестом с помощью подписки на сообщение, отправляемое тестируемым кодом, как показано в следующем примере кода:

```csharp
[Fact]  
public void AddCatalogItemCommandSendsAddProductMessageTest()  
{  
    bool messageReceived = false;  
    var catalogService = new CatalogMockService();  
    var catalogViewModel = new CatalogViewModel(catalogService);  

    Xamarin.Forms.MessagingCenter.Subscribe<CatalogViewModel, CatalogItem>(  
        this, MessageKeys.AddProduct, (sender, arg) =>  
    {  
        messageReceived = true;  
    });  
    catalogViewModel.AddCatalogItemCommand.Execute(null);  

    Assert.True(messageReceived);  
}
```

Этот модульный тест проверяет, `CatalogViewModel` публикует ли `AddProduct` сообщение в ответ на `AddCatalogItemCommand` выполнение. Поскольку [`MessagingCenter`](xref:Xamarin.Forms.MessagingCenter) класс поддерживает многоадресные подписки на сообщения, модульный тест может подписываться на `AddProduct` сообщение и выполнять делегат обратного вызова в ответ на его получение. Этот делегат обратного вызова, указанный в качестве лямбда-выражения, задает `boolean` поле, используемое `Assert` инструкцией для проверки поведения теста.

### <a name="testing-exception-handling"></a>Тестирование обработки исключений

Можно также написать модульные тесты, проверяющие, что для недопустимых действий или входных данных создаются определенные исключения, как показано в следующем примере кода:

```csharp
[Fact]  
public void InvalidEventNameShouldThrowArgumentExceptionText()  
{  
    var behavior = new MockEventToCommandBehavior  
    {  
        EventName = "OnItemTapped"  
    };  
    var listView = new ListView();  

    Assert.Throws<ArgumentException>(() => listView.Behaviors.Add(behavior));  
}
```

Этот модульный тест создаст исключение, так как [`ListView`](xref:Xamarin.Forms.ListView) элемент управления не имеет события с именем `OnItemTapped` . `Assert.Throws<T>`Метод является универсальным методом, где `T` — тип ожидаемого исключения. Аргумент, передаваемый в `Assert.Throws<T>` метод, является лямбда-выражением, которое будет вызывать исключение. Таким образом, модульный тест будет передавать при условии, что лямбда-выражение создает исключение `ArgumentException` .

> [!TIP]
> Избегайте написания модульных тестов, которые проверяют строки сообщений об исключениях. Строки сообщений об исключениях могут меняться со временем, поэтому модульные тесты, основанные на их присутствии, считаются нестабильным.

### <a name="testing-validation"></a>Проверка проверки

Тестирование реализации проверки имеет два аспекта: Проверка правильности реализации правил проверки и проверка того, что `ValidatableObject<T>` класс работает должным образом.

Логика проверки обычно проста в тестировании, так как обычно это автономный процесс, в котором выходные данные зависят от входных данных. Должны быть тесты для результатов вызова `Validate` метода для каждого свойства, имеющего по крайней мере одно связанное правило проверки, как показано в следующем примере кода:

```csharp
[Fact]  
public void CheckValidationPassesWhenBothPropertiesHaveDataTest()  
{  
    var mockViewModel = new MockViewModel();  
    mockViewModel.Forename.Value = "John";  
    mockViewModel.Surname.Value = "Smith";  

    bool isValid = mockViewModel.Validate();  

    Assert.True(isValid);  
}
```

Этот модульный тест проверяет успешность проверки, если два `ValidatableObject<T>` свойства в `MockViewModel` экземпляре содержат данные.

Кроме проверки успешности проверки, модульные тесты проверки должны также проверять значения `Value` `IsValid` свойств, и `Errors` каждого `ValidatableObject<T>` экземпляра, чтобы убедиться, что класс работает должным образом. В следующем примере кода показан модульный тест, который делает это:

```csharp
[Fact]  
public void CheckValidationFailsWhenOnlyForenameHasDataTest()  
{  
    var mockViewModel = new MockViewModel();  
    mockViewModel.Forename.Value = "John";  

    bool isValid = mockViewModel.Validate();  

    Assert.False(isValid);  
    Assert.NotNull(mockViewModel.Forename.Value);  
    Assert.Null(mockViewModel.Surname.Value);  
    Assert.True(mockViewModel.Forename.IsValid);  
    Assert.False(mockViewModel.Surname.IsValid);  
    Assert.Empty(mockViewModel.Forename.Errors);  
    Assert.NotEmpty(mockViewModel.Surname.Errors);  
}
```

Этот модульный тест проверяет, что проверка завершается ошибкой, если `Surname` свойство объекта `MockViewModel` не содержит данных, `Value` а `IsValid` свойство, и `Errors` каждого `ValidatableObject<T>` экземпляра заданы правильно.

## <a name="summary"></a>Сводка

Модульный тест принимает небольшую единицу приложения, обычно метод, изолирует его от оставшейся части кода и проверяет, правильно ли он работает. Его целью является проверка того, что каждая единица функциональности работает должным образом, чтобы ошибки не распространялись в течение всего приложения.

Поведение тестируемого объекта может быть изолировано путем замены зависимых объектов макетами объектов, имитирующих поведение зависимых объектов. Это позволяет выполнять модульные тесты без неудобного использования ресурсов, таких как веб-службы или базы данных.

Тестирование моделей и моделей представлений из приложений MVVM идентично тестированию любых других классов, и можно использовать одни и те же средства и методики.

## <a name="related-links"></a>Связанные ссылки

- [Скачать электронную книгу (2 МБ в формате PDF)](https://aka.ms/xamarinpatternsebook)
- [eShopOnContainers (GitHub) (пример)](https://github.com/dotnet-architecture/eShopOnContainers)
