---
title: Внедрение зависимостей
description: В этой главе объясняется, как мобильное приложение eShopOnContainers использует внедрение зависимостей для отделения конкретных типов от кода, который зависит от этих типов.
ms.prod: xamarin
ms.assetid: a150f2d1-06f8-4aed-ab4e-7a847d69f103
ms.technology: xamarin-forms
author: davidbritch
ms.author: dabritch
ms.date: 11/04/2019
no-loc:
- Xamarin.Forms
- Xamarin.Essentials
ms.openlocfilehash: 99cac3c597cf1d7351d3214ce59fd0a0a0a46400
ms.sourcegitcommit: 32d2476a5f9016baa231b7471c88c1d4ccc08eb8
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 06/18/2020
ms.locfileid: "84572355"
---
# <a name="dependency-injection"></a>Внедрение зависимостей

Как правило, конструктор класса вызывается при создании экземпляра объекта, а все значения, необходимые объекту, передаются в конструктор в качестве аргументов. Это пример внедрения зависимостей, который, в частности, называется *внедрением конструктора*. Зависимости, необходимые объекту, вставляются в конструктор.

Указывая зависимости как типы интерфейсов, внедрение зависимостей позволяет разделять конкретные типы от кода, зависящего от этих типов. Обычно используется контейнер, содержащий список регистраций и сопоставлений между интерфейсами и абстрактными типами, а также конкретные типы, реализующие или расширяющие эти типы.

Существуют также другие типы внедрения зависимостей, такие как *внедрение свойства*и *Внедрение вызова метода*, но они являются менее часто видимыми. Поэтому в этой главе основное внимание уделяется только выполнению внедрения конструктора с помощью контейнера внедрения зависимостей.

## <a name="introduction-to-dependency-injection"></a>Введение в внедрение зависимостей

Внедрение зависимостей представляет собой специализированную версию шаблона инверсии управления (IoC), где отзываемая проблема — это процесс получения необходимой зависимости. При внедрении зависимостей другой класс отвечает за внедрение зависимостей в объект во время выполнения. В следующем примере кода показано, как `ProfileViewModel` структурирован класс при использовании внедрения зависимостей.

```csharp
public class ProfileViewModel : ViewModelBase  
{  
    private IOrderService _orderService;  

    public ProfileViewModel(IOrderService orderService)  
    {  
        _orderService = orderService;  
    }  
    ...  
}
```

`ProfileViewModel`Конструктор получает `IOrderService` экземпляр в качестве аргумента, который внедряется другим классом. Единственная зависимость в `ProfileViewModel` классе относится к типу интерфейса. Таким образом, `ProfileViewModel` класс не имеет сведений о классе, который отвечает за создание экземпляра `IOrderService` объекта. Класс, отвечающий за создание экземпляра `IOrderService` объекта и его вставку в `ProfileViewModel` класс, называется *контейнером внедрения зависимостей*.

Контейнеры внедрения зависимостей уменьшают взаимосвязь между объектами, предоставляя возможность создавать экземпляры классов и управлять временем существования в зависимости от конфигурации контейнера. Во время создания объектов контейнер внедряет все зависимости, необходимые объекту. Если эти зависимости еще не созданы, контейнер сначала создает и разрешает их зависимости.

> [!NOTE]
> Внедрение зависимостей также может быть реализовано вручную с помощью фабрик. Однако использование контейнера предоставляет дополнительные возможности, такие как управление жизненным циклом и регистрация через сканирование сборок.

Использование контейнера внедрения зависимостей имеет несколько преимуществ.

- Контейнер устраняет необходимость класса для определения его зависимостей и управления временем существования.
- Контейнер позволяет сопоставлять реализованные зависимости, не влияя на класс.
- Контейнер упрощает тестирование, позволяя макетирование зависимостей.
- Контейнер повышает удобство поддержки, позволяя легко добавлять новые классы в приложение.

В контексте Xamarin.Forms приложения, использующего MVVM, контейнер внедрения зависимостей обычно используется для регистрации и разрешения моделей представлений, а также для регистрации служб и их внедрения в модели представления.

Существует множество доступных контейнеров внедрения зависимостей с помощью мобильного приложения eShopOnContainers, использующего Тиниок для управления созданием экземпляров модели представления и классов служб в приложении. Тиниок был выбран после оценки ряда различных контейнеров и обладает высокой производительностью мобильных платформ по сравнению с большинством хорошо известных контейнеров. Она упрощает создание слабо связанных приложений и предоставляет все функции, которые часто обнаруживаются в контейнерах внедрения зависимостей, в том числе методы для регистрации сопоставлений типов, разрешения объектов, управления жизненным циклом объектов и вставки зависимых объектов в конструкторы объектов, которые он разрешает. Дополнительные сведения о Тиниок см. в разделе [тиниок](https://github.com/grumpydev/TinyIoC/wiki) on GitHub.com.

В Тиниок `TinyIoCContainer` тип предоставляет контейнер внедрения зависимостей. На рис. 3-1 показаны зависимости при использовании этого контейнера, который создает экземпляр `IOrderService` объекта и внедряет его в `ProfileViewModel` класс.

![](dependency-injection-images/dependencyinjection.png "Dependencies example when using dependency injection")

**Рис. 3-1.** Зависимости при использовании внедрения зависимостей

Во время выполнения контейнер должен быть уверен, какую реализацию `IOrderService` интерфейса он должен создавать, прежде чем он сможет создать экземпляр `ProfileViewModel` объекта. Это включает в себя следующее:

- Контейнер, который решает, как создать экземпляр объекта, реализующего `IOrderService` интерфейс. Это называется *регистрацией*.
- Контейнер, создающий экземпляр объекта, который реализует `IOrderService` интерфейс, и `ProfileViewModel` объект. Это называется *разрешением*.

В конечном итоге приложение завершит использование `ProfileViewModel` объекта и станет доступным для сборки мусора. На этом этапе сборщик мусора должен удалить `IOrderService` экземпляр, если другие классы не используют один и тот же экземпляр.

> [!TIP]
> Написание кода, независимого от контейнера. Всегда пытайтесь записать код, не зависящий от контейнера, чтобы отделить приложение от конкретного используемого контейнера зависимостей.

## <a name="registration"></a>Регистрация

Прежде чем можно будет внедрить зависимости в объект, необходимо сначала зарегистрировать типы зависимостей в контейнере. Регистрация типа обычно подразумевает передачу контейнера интерфейс и конкретный тип, реализующий интерфейс.

Существует два способа регистрации типов и объектов в контейнере с помощью кода:

- Зарегистрируйте тип или сопоставление с контейнером. При необходимости контейнер будет строить экземпляр указанного типа.
- Зарегистрируйте существующий объект в контейнере как одноэлементный. При необходимости контейнер вернет ссылку на существующий объект.

> [!TIP]
> Контейнеры внедрения зависимостей не всегда подходят. Внедрение зависимостей предоставляет дополнительные сложности и требования, которые могут быть нецелесообразными или полезными для небольших приложений. Если у класса нет зависимостей или он не зависит от других типов, он может не иметь смысла размещать его в контейнере. Кроме того, если класс содержит один набор зависимостей, которые являются неотъемлемой частью типа и никогда не изменяются, может не иметь смысла размещать его в контейнере.

Регистрация типов, требующих внедрения зависимостей, должна выполняться в одном методе в приложении, и этот метод должен вызываться на раннем этапе жизненного цикла приложения, чтобы гарантировать, что приложение знает о зависимостях между его классами. В мобильном приложении eShopOnContainers это выполняется `ViewModelLocator` классом, который создает `TinyIoCContainer` объект и является единственным классом в приложении, который содержит ссылку на этот объект. В следующем примере кода показано, как мобильное приложение eShopOnContainers объявляет `TinyIoCContainer` объект в `ViewModelLocator` классе:

```csharp
private static TinyIoCContainer _container;
```

Типы регистрируются в `ViewModelLocator` конструкторе. Для этого сначала создается `TinyIoCContainer` экземпляр, который демонстрируется в следующем примере кода:

```csharp
_container = new TinyIoCContainer();
```

Затем типы регистрируются в `TinyIoCContainer` объекте, а в следующем примере кода демонстрируется наиболее распространенная форма регистрации типа:

```csharp
_container.Register<IRequestProvider, RequestProvider>();
```

`Register`Метод, показанный здесь, сопоставляет тип интерфейса с конкретным типом. По умолчанию каждая регистрация интерфейса настраивается как одноэлементный, чтобы каждый зависимый объект получал один и тот же общий экземпляр. Таким образом, `RequestProvider` в контейнере будет существовать только один экземпляр, который совместно используется объектами, требующими введения с `IRequestProvider` помощью конструктора.

Конкретные типы также могут быть зарегистрированы напрямую без сопоставления типа интерфейса, как показано в следующем примере кода:

```csharp
_container.Register<ProfileViewModel>();
```

По умолчанию каждая регистрация конкретного класса настраивается в виде нескольких экземпляров, чтобы каждый зависимый объект получал новый экземпляр. Таким образом, при `ProfileViewModel` разрешении будет создан новый экземпляр, и контейнер будет внедрять необходимые зависимости.

## <a name="resolution"></a>Решение

После регистрации типа его можно разрешить или внедрить как зависимость. Если тип разрешается и контейнеру необходимо создать новый экземпляр, он внедряет все зависимости в экземпляр.

Как правило, при разрешении типа происходит одно из трех действий:

1. Если тип не был зарегистрирован, контейнер создает исключение.
1. Если тип был зарегистрирован как одноэлементный, контейнер возвращает одноэлементный экземпляр. Если этот тип вызывается в первый раз, контейнер создает его при необходимости и сохраняет ссылку на него.
1. Если тип не был зарегистрирован как singleton, контейнер возвращает новый экземпляр и не поддерживает ссылку на него.

В следующем примере кода показано, как `RequestProvider` можно разрешить тип, который был ранее зарегистрирован в тиниок:

```csharp
var requestProvider = _container.Resolve<IRequestProvider>();
```

В этом примере Тиниок запрос на разрешение конкретного типа для `IRequestProvider` типа вместе с любыми зависимостями. Как правило, `Resolve` метод вызывается, когда требуется экземпляр определенного типа. Сведения об управлении временем существования разрешенных объектов см. [в разделе Управление временем существования разрешенных объектов](#managing-the-lifetime-of-resolved-objects).

В следующем примере кода показано, как мобильное приложение eShopOnContainers создает экземпляры типов моделей представления и их зависимостей:

```csharp
var viewModel = _container.Resolve(viewModelType);
```

В этом примере Тиниок запрос на разрешение типа модели представления для запрошенной модели представления, и контейнер также будет разрешать все зависимости. При разрешении `ProfileViewModel` типа зависимости для разрешения являются `ISettingsService` объектом и `IOrderService` объектом. Так как регистрации интерфейсов использовались при регистрации `SettingsService` `OrderService` классов и, тиниок возвращает одноэлементные экземпляры для `SettingsService` классов и, `OrderService` а затем передает их конструктору `ProfileViewModel` класса. Дополнительные сведения о том, как конструкция eShopOnContainers Mobile App формирует модели представления и связывает их с представлениями, см. в разделе [Автоматическое создание модели представления с указателем модели представления](~/xamarin-forms/enterprise-application-patterns/mvvm.md#automatically-creating-a-view-model-with-a-view-model-locator).

> [!NOTE]
> Регистрация и разрешение типов в контейнере влечет затраты с точки зрения производительности из-за использования отражения в контейнере для создания каждого типа, особенно если зависимости перестраиваются при каждом переходе по страницам в приложении. При наличии большого числа зависимостей или глубоких зависимостей стоимость создания может значительно возрасти.

## <a name="managing-the-lifetime-of-resolved-objects"></a>Управление временем существования разрешенных объектов

После регистрации типа с помощью регистрации конкретного класса поведением по умолчанию для Тиниок является создание нового экземпляра зарегистрированного типа каждый раз, когда тип разрешается, или когда механизм зависимости внедряет экземпляры в другие классы. В этом сценарии контейнер не хранит ссылку на разрешенный объект. Однако при регистрации типа с помощью регистрации интерфейса поведение по умолчанию для Тиниок заключается в управлении временем существования объекта в качестве одноэлементного. Таким образом, экземпляр остается в области, пока контейнер находится в области, и удаляется, когда контейнер выходит из области действия и уничтожается сборщиком мусора, или когда код явным образом удаляет контейнер.

Поведение регистрации Тиниок по умолчанию можно переопределить с помощью методов Fluent `AsSingleton` и `AsMultiInstance` API. Например, `AsSingleton` метод можно использовать с `Register` методом, чтобы контейнер создавал или возвращал одноэлементный экземпляр типа при вызове `Resolve` метода. В следующем примере кода показано, как Тиниок указывает, как создать одноэлементный экземпляр `LoginViewModel` класса:

```csharp
_container.Register<LoginViewModel>().AsSingleton();
```

При первом `LoginViewModel` разрешении типа контейнер создает новый `LoginViewModel` объект и сохраняет ссылку на него. При каждом последующих разрешениях `LoginViewModel` контейнер возвращает ссылку на `LoginViewModel` объект, который был создан ранее.

> [!NOTE]
> Типы, регистрируемые как singleton-экземпляры, удаляются при удалении контейнера.

## <a name="summary"></a>Сводка

Внедрение зависимостей позволяет разделять конкретные типы от кода, который зависит от этих типов. Обычно используется контейнер, содержащий список регистраций и сопоставлений между интерфейсами и абстрактными типами, а также конкретные типы, реализующие или расширяющие эти типы.

Тиниок — это упрощенный контейнер, который обладает высокой производительностью мобильных платформ по сравнению с большинством хорошо известных контейнеров. Она упрощает создание слабо связанных приложений и предоставляет все функции, которые часто обнаруживаются в контейнерах внедрения зависимостей, в том числе методы для регистрации сопоставлений типов, разрешения объектов, управления жизненным циклом объектов и вставки зависимых объектов в конструкторы объектов, которые он разрешает.

## <a name="related-links"></a>Связанные ссылки

- [Скачать электронную книгу (2 МБ в формате PDF)](https://aka.ms/xamarinpatternsebook)
- [eShopOnContainers (GitHub) (пример)](https://github.com/dotnet-architecture/eShopOnContainers)
