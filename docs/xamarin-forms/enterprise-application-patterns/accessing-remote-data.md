---
title: Доступ к удаленным данным
description: В этой главе объясняется, как мобильное приложение eShopOnContainers получает доступ к данным из контейнерных микрослужб.
ms.prod: xamarin
ms.assetid: 42eba6f5-9784-4e1a-9943-5c1fbeea7452
ms.technology: xamarin-forms
author: davidbritch
ms.author: dabritch
ms.date: 08/07/2017
no-loc:
- Xamarin.Forms
- Xamarin.Essentials
ms.openlocfilehash: b21fecf139262a88fbbe3de3ea8129cc0f9b211e
ms.sourcegitcommit: ebdc016b3ec0b06915170d0cbbd9e0e2469763b9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/05/2020
ms.locfileid: "93373358"
---
# <a name="accessing-remote-data"></a>Доступ к удаленным данным

> [!NOTE]
> Эта электронная книга была опубликована в пружине 2017 и не была обновлена с этого момента. В книге есть много ценных материалов, но некоторые из них устарели.

Многие современные веб-решения используют веб-службы, размещенные на веб-серверах, для обеспечения функциональности удаленных клиентских приложений. Предоставляемые веб-службой операции составляют веб-API.

Клиентские приложения должны иметь возможность использовать веб-API, не зная, как реализуются данные или операции, предоставляемые API. Для этого необходимо, чтобы API придерживается стандартных стандартов, позволяющих клиентскому приложению и веб-службе согласовать используемые форматы данных и структуру данных, которыми обмениваются клиентские приложения и веб-служба.

## <a name="introduction-to-representational-state-transfer"></a>Общие сведения о переносе состояния представления

Перестроение данных о состоянии (остальное) — это архитектурный стиль для создания распределенных систем на основе носителя. Основное преимущество модели RESTFUL заключается в том, что она основана на открытых стандартах и не привязывает реализацию модели или клиентских приложений, которые обращаются к ней к любой конкретной реализации. Таким образом, веб-службу RESTFUL можно реализовать с помощью Microsoft ASP.NET Core MVC, а клиентские приложения можно разрабатывать с помощью любого языка и набора инструментов, который может создавать HTTP-запросы и анализировать HTTP-ответы.

Модель RESTFUL использует схему навигации для представления объектов и служб по сети, называемые ресурсами. Системы, реализующие интерфейс RESTFUL, обычно используют протокол HTTP для передачи запросов на доступ к этим ресурсам. В таких системах клиентское приложение отправляет запрос в форме URI, который идентифицирует ресурс, и метод HTTP (например, GET, POST, WHERE или DELETE), указывающий операцию, выполняемую над этим ресурсом. Текст HTTP-запроса содержит все данные, необходимые для выполнения операции.

> [!NOTE]
> ОСТАЛЬНОЕ определяет модель запросов без отслеживания состояния. Поэтому HTTP-запросы должны быть независимыми и могут происходить в любом порядке.

Ответ от запроса на ОСТАЛЬной стороны использует стандартные коды состояния HTTP. Например, запрос, возвращающий допустимые данные, должен включать код HTTP-ответа 200 (ОК), в то время как запрос, по которому не удалось найти или удалить указанный ресурс, должен вернуть ответ, включающий код состояния HTTP 404 (не найдено).

Веб-API RESTFUL предоставляет набор подключенных ресурсов и предоставляет основные операции, позволяющие приложению манипулировать ресурсами и легко перемещаться между ними. По этой причине универсальные коды ресурсов (URI), составляющие стандартный веб-API RESTFUL, ориентированы на предоставляемые им данные и используют средства, предоставляемые HTTP, для работы с этими данными.

Данные, включаемые клиентским приложением в HTTP-запросе, и соответствующие ответные сообщения от веб сервера могут быть представлены в различных форматах, известных как типы мультимедиа. Когда клиентское приложение отправляет запрос, который возвращает данные в теле сообщения, он может указать типы мультимедиа, которые он может обменяться в `Accept` заголовке запроса. Если веб-сервер поддерживает этот тип мультимедиа, он может ответить ответом, содержащим `Content-Type` заголовок, указывающий формат данных в тексте сообщения. Затем клиентское приложение отвечает за синтаксический анализ ответного сообщения и интерпретирует результаты в тексте сообщения соответствующим образом.

Дополнительные сведения о функциях RESTFUL см. в разделе [Разработка API](/azure/architecture/best-practices/api-design/) и [реализация API](/azure/architecture/best-practices/api-implementation/).

## <a name="consuming-restful-apis"></a>Использование API-интерфейсов RESTFUL

Мобильное приложение eShopOnContainers использует шаблон Model-View-ViewModel (MVVM), а элементы модели шаблона — сущности предметной области, используемые в приложении. Классы контроллера и репозитория в эталонном приложении eShopOnContainers принимают и возвращают многие из этих объектов модели. Таким образом, они используются в качестве объектов передачи данных (DTO), которые содержат все данные, передаваемые между мобильным приложением и контейнерными микрослужбами. Основное преимущество использования DTO для передачи данных и получения данных из веб-службы заключается в том, что при передаче дополнительных данных в одном удаленном вызове приложение может уменьшить количество удаленных вызовов, которые необходимо выполнить.

### <a name="making-web-requests"></a>Выполнение веб-запросов

Мобильное приложение eShopOnContainers использует `HttpClient` класс для выполнения запросов по протоколу HTTP, в котором в качестве типа мультимедиа используется JSON. Этот класс предоставляет функциональные возможности асинхронной отправки HTTP-запросов и получения HTTP-ответов от идентифицированного ресурса URI. `HttpResponseMessage`Класс представляет сообщение HTTP-ответа, полученное от REST API после совершения HTTP-запроса. Он содержит сведения об ответе, включая код состояния, заголовков и любой текст. `HttpContent` Класс представляет тело HTTP и заголовки содержимого, таких как `Content-Type` и `Content-Encoding`. Содержимое может быть считано с помощью любого из `ReadAs` методов, например `ReadAsStringAsync` и, в `ReadAsByteArrayAsync` зависимости от формата данных.

#### <a name="making-a-get-request"></a>Выполнение запроса GET

`CatalogService`Класс используется для управления процессом извлечения данных из микрослужбы каталога. В `RegisterDependencies` методе `ViewModelLocator` класса `CatalogService` класс регистрируется как сопоставление типа `ICatalogService` с типом с помощью контейнера внедрения зависимостей Autofac. Затем, когда `CatalogViewModel` создается экземпляр класса, его конструктор принимает `ICatalogService` тип, который Autofac разрешается, возвращая экземпляр `CatalogService` класса. Дополнительные сведения о внедрении зависимостей см. [в разделе Введение в внедрение зависимостей](~/xamarin-forms/enterprise-application-patterns/dependency-injection.md#introduction-to-dependency-injection).

На рис. 10-1 показано взаимодействие классов, считывающих данные каталога из микрослужбы каталога для отображения в `CatalogView` .

[![Извлечение данных из микрослужбы каталога](accessing-remote-data-images/catalogdata.png)](accessing-remote-data-images/catalogdata-large.png#lightbox "Извлечение данных из микрослужбы каталога")

**Рис. 10-1**. получение данных из микрослужбы каталога

При `CatalogView` переходе к вызывается `OnInitialize` метод в `CatalogViewModel` классе. Этот метод извлекает данные каталога из микрослужбы каталога, как показано в следующем примере кода:

```csharp
public override async Task InitializeAsync(object navigationData)  
{  
    ...  
    Products = await _productsService.GetCatalogAsync();  
    ...  
}
```

Этот метод вызывает `GetCatalogAsync` метод `CatalogService` экземпляра, который был внедрен в `CatalogViewModel` Autofac. Метод `GetCatalogAsync` показан в следующем примере кода:

```csharp
public async Task<ObservableCollection<CatalogItem>> GetCatalogAsync()  
{  
    UriBuilder builder = new UriBuilder(GlobalSetting.Instance.CatalogEndpoint);  
    builder.Path = "api/v1/catalog/items";  
    string uri = builder.ToString();  

    CatalogRoot catalog = await _requestProvider.GetAsync<CatalogRoot>(uri);  
    ...  
    return catalog?.Data.ToObservableCollection();            
}
```

Этот метод создает URI, определяющий ресурс, в который будет отправлен запрос, и использует `RequestProvider` класс для вызова метода GET HTTP для ресурса перед возвратом результатов в `CatalogViewModel` . `RequestProvider`Класс содержит функциональные возможности, которые отправляют запрос в форме URI, который идентифицирует ресурс, метод HTTP, указывающий операцию, выполняемую с этим ресурсом, и текст, содержащий все данные, необходимые для выполнения операции. Сведения о `RequestProvider` внедрении класса в см `CatalogService class` . в разделе [Введение в внедрение зависимостей](~/xamarin-forms/enterprise-application-patterns/dependency-injection.md#introduction-to-dependency-injection).

В следующем примере кода показан `GetAsync` метод в `RequestProvider` классе:

```csharp
public async Task<TResult> GetAsync<TResult>(string uri, string token = "")  
{  
    HttpClient httpClient = CreateHttpClient(token);  
    HttpResponseMessage response = await httpClient.GetAsync(uri);  

    await HandleResponse(response);  
    string serialized = await response.Content.ReadAsStringAsync();  

    TResult result = await Task.Run(() =>   
        JsonConvert.DeserializeObject<TResult>(serialized, _serializerSettings));  

    return result;  
}
```

Этот метод вызывает `CreateHttpClient` метод, который возвращает экземпляр `HttpClient` класса с соответствующим набором заголовков. Затем он отправляет асинхронный запрос GET в ресурс, идентифицируемый с помощью URI, с ответом, хранящимся в `HttpResponseMessage` экземпляре. `HandleResponse`Затем вызывается метод, который вызывает исключение, если ответ не содержит код состояния успешного HTTP. Затем ответ считывается в виде строки, преобразуется из JSON в `CatalogRoot` объект и возвращается в `CatalogService` .

`CreateHttpClient`Метод показан в следующем примере кода:

```csharp
private HttpClient CreateHttpClient(string token = "")  
{  
    var httpClient = new HttpClient();  
    httpClient.DefaultRequestHeaders.Accept.Add(  
        new MediaTypeWithQualityHeaderValue("application/json"));  

    if (!string.IsNullOrEmpty(token))  
    {  
        httpClient.DefaultRequestHeaders.Authorization =   
            new AuthenticationHeaderValue("Bearer", token);  
    }  
    return httpClient;  
}
```

Этот метод создает новый экземпляр `HttpClient` класса и устанавливает `Accept` заголовок всех запросов, выполняемых `HttpClient` экземпляром `application/json` , который указывает, что он требует, чтобы содержимое любого ответа было отформатировано с помощью JSON. Затем, если маркер доступа передан в качестве аргумента в `CreateHttpClient` метод, он добавляется в `Authorization` заголовок всех запросов, выполняемых `HttpClient` экземпляром, с префиксом строки `Bearer` . Дополнительные сведения об авторизации см. в разделе [авторизация](~/xamarin-forms/enterprise-application-patterns/authentication-and-authorization.md#authorization).

При `GetAsync` вызове метода в `RequestProvider` классе `HttpClient.GetAsync` `Items` `CatalogController` вызывается метод в классе в проекте Catalog. API, который показан в следующем примере кода:

```csharp
[HttpGet]  
[Route("[action]")]  
public async Task<IActionResult> Items(  
    [FromQuery]int pageSize = 10, [FromQuery]int pageIndex = 0)  
{  
    var totalItems = await _catalogContext.CatalogItems  
        .LongCountAsync();  

    var itemsOnPage = await _catalogContext.CatalogItems  
        .OrderBy(c=>c.Name)  
        .Skip(pageSize * pageIndex)  
        .Take(pageSize)  
        .ToListAsync();  

    itemsOnPage = ComposePicUri(itemsOnPage);  
    var model = new PaginatedItemsViewModel<CatalogItem>(  
        pageIndex, pageSize, totalItems, itemsOnPage);             

    return Ok(model);  
}
```

Этот метод получает данные каталога из базы данных SQL с помощью EntityFramework и возвращает их как ответное сообщение, содержащее код состояния HTTP Success и коллекцию отформатированных `CatalogItem` экземпляров JSON.

#### <a name="making-a-post-request"></a>Выполнение запроса POST

`BasketService`Класс используется для управления получением и обновлением данных с помощью микрослужбы корзины. В `RegisterDependencies` методе `ViewModelLocator` класса `BasketService` класс регистрируется как сопоставление типа `IBasketService` с типом с помощью контейнера внедрения зависимостей Autofac. Затем, когда `BasketViewModel` создается экземпляр класса, его конструктор принимает `IBasketService` тип, который Autofac разрешается, возвращая экземпляр `BasketService` класса. Дополнительные сведения о внедрении зависимостей см. [в разделе Введение в внедрение зависимостей](~/xamarin-forms/enterprise-application-patterns/dependency-injection.md#introduction-to-dependency-injection).

На рис. 10-2 показано взаимодействие классов, которые отправляют данные корзины, отображаемые в `BasketView` , в микрослужбу корзины.

[![Отправка данных в микрослужбу корзины](accessing-remote-data-images/basketdata.png)](accessing-remote-data-images/basketdata-large.png#lightbox "Отправка данных в микрослужбу корзины")

**Рис. 10-2**. Отправка данных в микрослужбу корзины

При добавлении элемента в корзину для покупок `ReCalculateTotalAsync` `BasketViewModel` вызывается метод в классе. Этот метод обновляет общее значение элементов в корзине и отправляет данные о корзине в микрослужбу корзины, как показано в следующем примере кода:

```csharp
private async Task ReCalculateTotalAsync()  
{  
    ...  
    await _basketService.UpdateBasketAsync(new CustomerBasket  
    {  
        BuyerId = userInfo.UserId,   
        Items = BasketItems.ToList()  
    }, authToken);  
}
```

Этот метод вызывает `UpdateBasketAsync` метод `BasketService` экземпляра, который был внедрен в `BasketViewModel` Autofac. Следующий метод демонстрирует `UpdateBasketAsync` метод:

```csharp
public async Task<CustomerBasket> UpdateBasketAsync(CustomerBasket customerBasket, string token)  
{  
    UriBuilder builder = new UriBuilder(GlobalSetting.Instance.BasketEndpoint);  
    string uri = builder.ToString();  
    var result = await _requestProvider.PostAsync(uri, customerBasket, token);  
    return result;  
}
```

Этот метод создает URI, определяющий ресурс, в который будет отправлен запрос, и использует `RequestProvider` класс для вызова HTTP-метода POST для ресурса перед возвратом результатов в `BasketViewModel` . Обратите внимание, что маркер доступа, полученный от IdentityServer во время процесса проверки подлинности, необходим для авторизации запросов к микрослужбе корзины. Дополнительные сведения об авторизации см. в разделе [авторизация](~/xamarin-forms/enterprise-application-patterns/authentication-and-authorization.md#authorization).

В следующем примере кода показан один из `PostAsync` методов `RequestProvider` класса:

```csharp
public async Task<TResult> PostAsync<TResult>(  
    string uri, TResult data, string token = "", string header = "")  
{  
    HttpClient httpClient = CreateHttpClient(token);  
    ...  
    var content = new StringContent(JsonConvert.SerializeObject(data));  
    content.Headers.ContentType = new MediaTypeHeaderValue("application/json");  
    HttpResponseMessage response = await httpClient.PostAsync(uri, content);  

    await HandleResponse(response);  
    string serialized = await response.Content.ReadAsStringAsync();  

    TResult result = await Task.Run(() =>  
        JsonConvert.DeserializeObject<TResult>(serialized, _serializerSettings));  

    return result;  
}
```

Этот метод вызывает `CreateHttpClient` метод, который возвращает экземпляр `HttpClient` класса с соответствующим набором заголовков. Затем он отправляет асинхронный запрос POST к ресурсу, определяемому универсальным кодом ресурса (URI), а сериализованные данные корзины отправляются в формате JSON и ответ, хранящийся в `HttpResponseMessage` экземпляре. `HandleResponse`Затем вызывается метод, который вызывает исключение, если ответ не содержит код состояния успешного HTTP. Затем ответ считывается в виде строки, преобразуется из JSON в `CustomerBasket` объект и возвращается в `BasketService` . Дополнительные сведения о `CreateHttpClient` методе см. в разделе [Создание запроса GET](#making-a-get-request).

При `PostAsync` вызове метода в `RequestProvider` классе `HttpClient.PostAsync` `Post` `BasketController` вызывается метод в классе в проекте корзины. API, который показан в следующем примере кода:

```csharp
[HttpPost]  
public async Task<IActionResult> Post([FromBody]CustomerBasket value)  
{  
    var basket = await _repository.UpdateBasketAsync(value);  
    return Ok(basket);  
}
```

Этот метод использует экземпляр `RedisBasketRepository` класса для сохранения данных корзины в кэш Redis и возвращает его как ответное сообщение, содержащее код состояния HTTP Success и экземпляр отформатированного JSON `CustomerBasket` .

#### <a name="making-a-delete-request"></a>Выполнение запроса на удаление

На рис. 10-3 показано взаимодействие классов, которые удаляют данные из корзины из микрослужбы корзины для `CheckoutView` .

![Удаление данных из микрослужбы корзины](accessing-remote-data-images/checkoutdata.png)

**Рис. 10-3**. Удаление данных из микрослужбы корзины

При вызове процесса извлечения `CheckoutAsync` `CheckoutViewModel` вызывается метод в классе. Этот метод создает новый заказ перед очисткой корзины покупок, как показано в следующем примере кода:

```csharp
private async Task CheckoutAsync()  
{  
    ...  
    await _basketService.ClearBasketAsync(_shippingAddress.Id.ToString(), authToken);  
    ...  
}
```

Этот метод вызывает `ClearBasketAsync` метод `BasketService` экземпляра, который был внедрен в `CheckoutViewModel` Autofac. Следующий метод демонстрирует `ClearBasketAsync` метод:

```csharp
public async Task ClearBasketAsync(string guidUser, string token)  
{  
    UriBuilder builder = new UriBuilder(GlobalSetting.Instance.BasketEndpoint);  
    builder.Path = guidUser;  
    string uri = builder.ToString();  
    await _requestProvider.DeleteAsync(uri, token);  
}
```

Этот метод создает URI, определяющий ресурс, в который будет отправлен запрос, и использует `RequestProvider` класс для вызова метода Delete HTTP для ресурса. Обратите внимание, что маркер доступа, полученный от IdentityServer во время процесса проверки подлинности, необходим для авторизации запросов к микрослужбе корзины. Дополнительные сведения об авторизации см. в разделе [авторизация](~/xamarin-forms/enterprise-application-patterns/authentication-and-authorization.md#authorization).

В следующем примере кода показан `DeleteAsync` метод в `RequestProvider` классе:

```csharp
public async Task DeleteAsync(string uri, string token = "")  
{  
    HttpClient httpClient = CreateHttpClient(token);  
    await httpClient.DeleteAsync(uri);  
}
```

Этот метод вызывает `CreateHttpClient` метод, который возвращает экземпляр `HttpClient` класса с соответствующим набором заголовков. Затем он отправляет асинхронный запрос DELETE к ресурсу, определяемому универсальным кодом ресурса (URI). Дополнительные сведения о `CreateHttpClient` методе см. в разделе [Создание запроса GET](#making-a-get-request).

При `DeleteAsync` вызове метода в `RequestProvider` классе `HttpClient.DeleteAsync` `Delete` `BasketController` вызывается метод в классе в проекте корзины. API, который показан в следующем примере кода:

```csharp
[HttpDelete("{id}")]  
public void Delete(string id)  
{  
    _repository.DeleteBasketAsync(id);  
}
```

Этот метод использует экземпляр `RedisBasketRepository` класса для удаления данных корзины из кэша Redis.

## <a name="caching-data"></a>Кэширование данных

Производительность приложения можно улучшить путем кэширования часто используемых данных в быстром хранилище, расположенном ближе к приложению. Если быстрое хранилище расположено ближе к приложению, чем исходный источник, то кэширование может значительно повысить время отклика при извлечении данных.

Наиболее распространенная форма кэширования — это кэширование, в котором приложение получает данные, ссылаясь на кэш. Если данные находятся не в кэше, они извлекаются из хранилища данных и добавляются в кэш. Приложения могут реализовывать кэширование для чтения с использованием шаблона кэша. Этот шаблон определяет, находится ли элемент в кэше в данный момент. Если элемент отсутствует в кэше, он считывается из хранилища данных и добавляется в кэш. Дополнительные сведения см. в разделе шаблон [кэша](/azure/architecture/patterns/cache-aside/) .

> [!TIP]
> Данные кэша, которые считываются часто, и изменяются редко. Эти данные могут быть добавлены в кэш по запросу при первом получении приложением. Это означает, что приложение должно получать данные только один раз из хранилища данных, и этот доступ может быть удовлетворен с помощью кэша.

Распределенные приложения, такие как эталонное приложение eShopOnContainers, должны предоставлять один или оба следующих кэша:

- Общий кэш, к которому могут обращаться несколько процессов или машин.
- Частный кэш, где данные хранятся локально на устройстве, где запущено приложение.

Мобильное приложение eShopOnContainers использует частный кэш, где данные хранятся локально на устройстве, где выполняется экземпляр приложения. Сведения о кэше, используемом эталонным приложением eShopOnContainers, см. в разделе [.NET микрослужбы: архитектура для контейнерных приложений .NET](https://aka.ms/microservicesebook).

> [!TIP]
> Кэш можно рассматривать как временное хранилище данных, которое может исчезнуть в любое время. Убедитесь, что данные хранятся в исходном хранилище данных, а также в кэше. Вероятность потери данных затем уменьшается, если кэш становится недоступным.

### <a name="managing-data-expiration"></a>Управление истечением срока действия данных

Нецелесообразно рассчитывать, что кэшированные данные всегда будут соответствовать исходным данным. Данные в исходном хранилище данных могут измениться после кэширования, что приведет к тому, что кэшированные данные станут устаревшими. Таким образом, приложения должны реализовать стратегию, которая помогает обеспечить актуальность данных в кэше, но также может обнаруживать и справляться с ситуациями, возникающими, когда данные в кэше устаревают. Большинство механизмов кэширования позволяют настроить кэш для истечения срока действия данных и, следовательно, сократить период, в течение которого данные могут устареть.

> [!TIP]
> Задайте срок действия по умолчанию при настройке кэша. Многие кэши реализуют истечение срока действия, что делает недействительными данные и удаляет их из кэша, если к ним нет доступа в течение указанного периода. Однако следует соблюдать осторожность при выборе срока действия. Если он слишком короткий, срок действия данных истечет слишком быстро, и преимущества кэширования будут сокращены. Если он слишком длинный, риски с данными устаревают. Поэтому срок действия должен соответствовать шаблону доступа для приложений, использующих данные.

После истечения срока действия кэшированных данных их следует удалить из кэша, и приложение должно получить данные из исходного хранилища данных и поместить их обратно в кэш.

Также возможно, что кэш может заполниться, если данные могут оставаться в течение слишком долгого времени. Таким образом, запросы на добавление новых элементов в кэш могут потребоваться для удаления некоторых элементов в процессе, называемом *вытеснением*. Службы кэширования обычно исключают данные на основе наиболее часто используемых. Однако существуют другие политики вытеснения, включая наиболее часто используемые и полученные по первыму времени. Дополнительные сведения см. в разделе [руководство по кэшированию](/azure/architecture/best-practices/caching/).

### <a name="caching-images"></a>Кэширование образов

Мобильное приложение eShopOnContainers использует удаленные образы продуктов, которые пользуются преимуществами кэширования. Эти изображения отображаются [`Image`](xref:Xamarin.Forms.Image) элементом управления и `CachedImage` элементом управления, предоставляемым библиотекой [ффимажелоадинг](https://www.nuget.org/packages/Xamarin.FFImageLoading.Forms/) .

Xamarin.Forms [`Image`](xref:Xamarin.Forms.Image) Элемент управления поддерживает кэширование скачанных образов. По умолчанию кэширование включено, и образ будет храниться локально в течение 24 часов. Кроме того, время истечения срока действия можно настроить с помощью [`CacheValidity`](xref:Xamarin.Forms.UriImageSource.CacheValidity) Свойства. Дополнительные сведения см. в статье [кэширование скачанных образов](~/xamarin-forms/user-interface/images.md#downloaded-image-caching).

`CachedImage`Элемент управления ффимажелоадинг является заменой для Xamarin.Forms [`Image`](xref:Xamarin.Forms.Image) элемента управления, предоставляя дополнительные свойства, обеспечивающие дополнительные функции. В этих функциях элемент управления обеспечивает настраиваемое кэширование, обеспечивая поддержку ошибок и загрузку заполнителей изображений. В следующем примере кода показано, как мобильное приложение eShopOnContainers использует `CachedImage` элемент управления в `ProductTemplate` , который является шаблоном данных, используемым [`ListView`](xref:Xamarin.Forms.ListView) элементом управления в `CatalogView` :

```xaml
<ffimageloading:CachedImage
    Grid.Row="0"
    Source="{Binding PictureUri}"     
    Aspect="AspectFill">
    <ffimageloading:CachedImage.LoadingPlaceholder>
        <OnPlatform x:TypeArguments="ImageSource">
            <On Platform="iOS, Android" Value="default_campaign" />
            <On Platform="UWP" Value="Assets/default_campaign.png" />
        </OnPlatform>
    </ffimageloading:CachedImage.LoadingPlaceholder>
    <ffimageloading:CachedImage.ErrorPlaceholder>
        <OnPlatform x:TypeArguments="ImageSource">
            <On Platform="iOS, Android" Value="noimage" />
            <On Platform="UWP" Value="Assets/noimage.png" />
        </OnPlatform>
    </ffimageloading:CachedImage.ErrorPlaceholder>
</ffimageloading:CachedImage>
```

`CachedImage`Элемент управления задает `LoadingPlaceholder` Свойства и `ErrorPlaceholder` для образов, зависящих от платформы. `LoadingPlaceholder`Свойство определяет изображение, отображаемое во время `Source` извлечения изображения, указанного свойством, а `ErrorPlaceholder` свойство указывает изображение, отображаемое при попытке получить изображение, указанное `Source` свойством.

Как предполагает имя, `CachedImage` элемент управления кэширует удаленные образы на устройстве на время, указанное значением `CacheDuration` Свойства. Если значение этого свойства не задано явно, применяется значение по умолчанию, равное 30 дням.

## <a name="increasing-resilience"></a>Повышение устойчивости

Все приложения, взаимодействующие с удаленными службами и ресурсами, должны быть чувствительны к временным сбоям. Временные сбои включают в себя недоступность сетевого подключения к службам, временную неработоспособность службы или время ожидания, возникающее, когда служба занята. Эти ошибки часто являются самодостаточными, и если действие повторяется после истечения подходящей задержки, скорее всего, оно будет завершено.

Временные сбои могут оказать огромное влияние на воспринимаемое качество приложения, даже если оно было тщательно протестировано во всех ожидаемых обстоятельствах. Чтобы обеспечить надежное функционирование приложения, которое взаимодействует с удаленными службами, оно должно иметь возможность выполнять следующие действия:

- Выявлять сбои при их возникновении и определять, являются ли сбои временными.
- Повторите операцию, если она определяет, что ошибка, вероятно, является временной и следит за количеством повторных попыток выполнения операции.
- Используйте соответствующую стратегию повторных попыток, которая указывает количество повторных попыток, задержку между попытками и действия, выполняемые после неудачной попытки.

Эта временная обработка сбоев может быть достигнута путем заключения всех попыток доступа к удаленной службе в коде, который реализует шаблон повтора.

### <a name="retry-pattern"></a>Шаблон повторных попыток

Если приложение обнаруживает сбой при попытке отправить запрос удаленной службе, это может привести к сбою одним из следующих способов:

- Выполняется повтор операции. Приложение может немедленно повторить неудачный запрос.
- Повтор операции после задержки. Приложение должно ожидать подходящее количество времени, прежде чем повторять запрос.
- Отмена операции. Приложение должно отменить операцию и сообщить об исключении.

Стратегия повтора должна быть настроена в соответствии с бизнес-требованиями приложения. Например, важно оптимизировать число повторных попыток и интервал повторных попыток для выполняемой операции. Если операция является частью взаимодействия с пользователем, интервал повторных попыток должен быть небольшим и лишь несколько повторных попыток, чтобы избежать того, что пользователи ожидают ответа. Если операция является частью длительно выполняемого рабочего процесса, в котором Отмена или перезапуск рабочего процесса требует дорогостоящего или длительного времени, то можно подождать более длительного ожидания между попытками и повторить попытку.

> [!NOTE]
> Интенсивная стратегия повторных попыток с минимальной задержкой между попытками и большим количеством повторных попыток может привести к снижению удаленной службы, которая работает близко к емкости или с ней. Кроме того, такая стратегия повторных попыток может также повлиять на скорость реагирования приложения, если она постоянно пытается выполнить неудачную операцию.

Если запрос по-прежнему завершается неудачей после нескольких повторных попыток, приложение лучше предотвратить дальнейшие запросы к тому же ресурсу и сообщить об ошибке. Затем, после установленного периода, приложение может выполнить один или несколько запросов к ресурсу, чтобы проверить успешность их выполнения. Дополнительные сведения см. в разделе [шаблон](#circuit-breaker-pattern)автоматического выключения.

> [!TIP]
> Никогда не применяйте механизм с бесконечными повторными попытками. Используйте конечное количество повторных попыток или Реализуйте шаблон [автоматического](/azure/architecture/patterns/circuit-breaker/) выключения, чтобы обеспечить возможность восстановления службы.

В настоящее время мобильное приложение eShopOnContainers не реализует шаблон повторных попыток при выполнении веб-запросов RESTFUL. Однако `CachedImage` элемент управления, предоставляемый библиотекой [ффимажелоадинг](https://www.nuget.org/packages/Xamarin.FFImageLoading.Forms/) , поддерживает обработку временных сбоев за счет повторной попытки загрузки образа. Если загрузка образа завершается сбоем, будут выполнены дальнейшие попытки. Число попыток указывается `RetryCount` свойством, и повторные попытки будут выполнены после задержки, указанной `RetryDelay` свойством. Если эти значения свойств не заданы явно, применяются значения по умолчанию – 3 для `RetryCount` Свойства и 250 мс для `RetryDelay` Свойства. Дополнительные сведения об `CachedImage` элементе управления см. в разделе [кэширование образов](#caching-images).

В эталонном приложении eShopOnContainers реализуется шаблон повторных попыток. Дополнительные сведения, включая обсуждение того, как объединить шаблон повторных попыток с `HttpClient` классом, см. в разделе [микрослужбы .NET — архитектура для контейнерных приложений .NET](https://aka.ms/microservicesebook).

Дополнительные сведения о шаблоне повтора см. в описании шаблона [повтора](/azure/architecture/patterns/retry/) .

### <a name="circuit-breaker-pattern"></a>Принцип «размыкателя сети»

В некоторых ситуациях ошибки могут возникать из-за ожидаемых событий, для устранения которых требуется больше времени. Эти ошибки могут варьироваться от частичной потери подключения до полного сбоя службы. В таких ситуациях приложение не имеет точки, чтобы повторить операцию, которая вряд ли будет выполнена, и вместо этого должна принять решение о сбое операции и соответствующим образом справиться с этим сбоем.

Шаблон автоматического выключения может помешать приложению многократно пытаться выполнить операцию, которая, скорее всего, завершится ошибкой, а также позволит приложению определить, устранена ли ошибка.

> [!NOTE]
> Назначение шаблона автоматического выключения отличается от шаблона повторного выполнения. Шаблон повторных попыток позволяет приложению повторить операцию в ожидании, что оно будет выполняться. Шаблон автоматического выключения не позволяет приложению выполнить операцию, которая, скорее всего, завершится ошибкой.

Автоматическое выключение действует в качестве прокси-сервера операций, которые могут завершиться со сбоем. Прокси-сервер должен отслеживать количество недавно произошедших сбоев и использовать эти сведения, чтобы решить, следует ли разрешить выполнение операции или немедленно возвращать исключение.

В настоящее время мобильное приложение eShopOnContainers не реализует шаблон автоматического выключения. Однако eShopOnContainers делает. Дополнительные сведения см. в статье [.NET микрослужбы: архитектура для контейнерных приложений .NET](https://aka.ms/microservicesebook).

> [!TIP]
> Объединение шаблонов повторных попыток и автоматического выключения. Приложение может сочетать шаблоны повтора и повторного запуска, используя шаблон повтора для вызова операции через автоматическое выключение. Однако логика повторения должна быть чувствительной к любым исключениям, возвращаемым автоматическим выключением, и отказываться от повторных попыток, если автоматическое выключение указывает, что неисправность не является временной.

Дополнительные сведения о шаблоне автоматического выключения см [. в разделе](/azure/architecture/patterns/circuit-breaker/) шаблон автоматического выключения.

## <a name="summary"></a>Сводка

Многие современные веб-решения используют веб-службы, размещенные на веб-серверах, для обеспечения функциональности удаленных клиентских приложений. Операции, предоставляемые веб-службой, составляют веб-API, а клиентские приложения должны иметь возможность использовать веб-API, не зная, как реализуются данные или операции, предоставляемые API.

Производительность приложения можно улучшить путем кэширования часто используемых данных в быстром хранилище, расположенном ближе к приложению. Приложения могут реализовывать кэширование для чтения с использованием шаблона кэша. Этот шаблон определяет, находится ли элемент в кэше в данный момент. Если элемент отсутствует в кэше, он считывается из хранилища данных и добавляется в кэш.

При взаимодействии с веб-API приложения должны быть чувствительны к временным сбоям. Временные сбои включают в себя недоступность сетевого подключения к службам, временную неработоспособность службы или время ожидания, возникающее, когда служба занята. Эти ошибки часто являются самодостаточными, и если действие повторяется после подходящей задержки, скорее всего, оно будет выполняться. Поэтому приложения должны переносить все попытки доступа к веб-API в коде, который реализует механизм обработки временных сбоев.

## <a name="related-links"></a>Связанные ссылки

- [Скачать электронную книгу (2 МБ в формате PDF)](https://aka.ms/xamarinpatternsebook)
- [eShopOnContainers (GitHub) (пример)](https://github.com/dotnet-architecture/eShopOnContainers)
