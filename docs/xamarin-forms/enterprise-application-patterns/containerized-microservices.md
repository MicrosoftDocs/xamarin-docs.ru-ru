---
title: Контейнерные микрослужбы
description: В этой главе объясняется, как использовать микрослужбы и контейнеры для создания гибких, масштабируемых и надежных современных облачных приложений.
ms.prod: xamarin
ms.assetid: 5872ad92-04e0-4f1a-9691-79d5602f5683
ms.technology: xamarin-forms
author: davidbritch
ms.author: dabritch
ms.date: 08/07/2017
no-loc:
- Xamarin.Forms
- Xamarin.Essentials
ms.openlocfilehash: 310a4e94a91eeb0d8d1c1f6ccb6fa30f0ff1f563
ms.sourcegitcommit: ebdc016b3ec0b06915170d0cbbd9e0e2469763b9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/05/2020
ms.locfileid: "93366572"
---
# <a name="containerized-microservices"></a>Контейнерные микрослужбы

> [!NOTE]
> Эта электронная книга была опубликована в пружине 2017 и не была обновлена с этого момента. В книге есть много ценных материалов, но некоторые из них устарели.

Разработка приложений Client-Server привела к созданию многоуровневых приложений, использующих определенные технологии на каждом уровне. Такие приложения часто называют *монолитными* приложениями и упаковываются на оборудование для пиковых нагрузок. Основным недостатком этого подхода разработки является тесная связь между компонентами внутри каждого уровня, что отдельные компоненты невозможно легко масштабировать и затраты на тестирование. Простое обновление может иметь непредвиденные последствия на остальной части уровня, поэтому изменение компонента приложения требует повторного тестирования и повторного развертывания всего уровня.

В частности, в случае с возрастом облака, можно легко масштабировать отдельные компоненты. Монолитное приложение содержит функциональные возможности, зависящие от домена, и обычно разделяется функциональными уровнями, такими как интерфейсная часть, Бизнес-логика и хранилище данных. Монолитное приложение масштабируется путем клонирования всего приложения на несколько компьютеров, как показано на рисунке 8-1.

![Подход монолитного масштабирования приложений](containerized-microservices-images/monolithicapp.png)

**Рис. 8-1**. подход монолитного масштабирования приложений

## <a name="microservices"></a>Микрослужбы

Микрослужбы предлагают другой подход к разработке и развертыванию приложений, подход, который подходит для обеспечения гибкости, масштабирования и надежности современных облачных приложений. Приложение микрослужб разбивается на независимые компоненты, которые совместно работают для предоставления общей функциональности приложения. Термин «микрослужба» подчеркивает, что приложения должны быть состоять из служб, достаточных для отражения независимых проблем, чтобы каждая микрослужба реализовала одну функцию. Кроме того, каждая микрослужба имеет четко определенные контракты, чтобы другие микрослужбы могли обмениваться данными и обмениваться ими. Типичные примеры микрослужб включают в себя корзины покупок, обработку запасов, подсистемы покупок и обработку платежей.

Микрослужбы могут масштабироваться независимо друг от друга, по сравнению с гигантским монолитным приложением, которое масштабируется вместе. Это означает, что конкретная функциональная область, требующая большего объема вычислительной мощности или пропускной способности сети для поддержки спроса, может масштабироваться, а не иметь необходимости в масштабировании других областей приложения. На рис. 8-2 показан этот подход, когда микрослужбы развертываются и масштабируются независимо друг от друга, создавая экземпляры служб на разных компьютерах.

![Подход к масштабированию приложений микрослужб](containerized-microservices-images/microservicesapp.png)

**Рис. 8-2**. подход к масштабированию приложений микрослужб

Горизонтальное масштабирование микрослужб может выполняться практически мгновенно, позволяя приложению адаптироваться к изменяющимся нагрузкам. Например, одна микрослужба в веб-функции приложения может быть единственной микрослужбой в приложении, которую необходимо масштабировать для обработки дополнительного входящего трафика.

Классическая модель масштабируемости приложений заключается в том, что для хранения постоянных данных используется балансировка нагрузки, уровень без сохранения состояния с общим внешним хранилищем. Микрослужбы с отслеживанием состояния управляют собственными постоянными данными, обычно сохраняя их локально на серверах, на которых они размещены, чтобы избежать издержек при доступе к сети и сложности операций между службами. Это позволяет максимально быстро обрабатывать данные и устранять потребность в системах кэширования. Кроме того, масштабируемые микрослужбы с отслеживанием состояния обычно разделяют данные между своими экземплярами, чтобы управлять размером данных и пропускной способностью передачи, за пределами которых может поддерживаться один сервер.

Микрослужбы также поддерживают независимые обновления. Такая слабая связь между микрослужбами обеспечивает быстрое и надежное развитие приложений. Независимая, распределенная природа поддерживает последовательное обновление, когда только подмножество экземпляров одной микрослужбы будет обновляться в любой конкретный момент времени. Поэтому при обнаружении проблемы можно выполнить откат обновления ошибками, прежде чем все экземпляры будут обновлены с помощью неисправного кода или конфигурации. Аналогичным образом микрослужбы обычно используют управление версиями схемы, так что клиенты видят последовательную версию при применении обновлений независимо от того, с каким экземпляром микрослужб осуществляется обмен данными.

Поэтому приложения микрослужб имеют множество преимуществ по сравнению с монолитными приложениями:

- Каждая микрослужба относительно невелика, легко управляется и развивается.
- Каждую микрослужбу можно разрабатывать и развертывать независимо от других служб.
- Каждую микрослужбу можно масштабировать независимо. Например, может потребоваться горизонтальное масштабирование службы каталогов или покупательской корзины, чем служба заказа. Таким образом, полученная инфраструктура будет более эффективно потреблять ресурсы при масштабировании.
- Каждая микрослужба изолирует любые проблемы. Например, если в службе возникает ошибка, она влияет только на эту службу. Другие службы могут продолжать обработку запросов.
- Каждая микрослужба может использовать новейшие технологии. Поскольку микрослужбы автономны и работают параллельно, можно использовать новейшие технологии и платформы, а не использовать более старую платформу, которая может использоваться монолитным приложением.

Однако решение на основе микрослужб также имеет потенциальные недостатки:

- Выбор способа разбиения приложения на микрослужбы может оказаться сложной задачей, так как каждая микрослужба должна быть полностью автономной, включая ответственность за источники данных.
- Разработчики должны реализовать взаимодействие между службами, что повышает сложность и задержку в приложении.
- Атомарные транзакции между несколькими микрослужбами обычно невозможны. Поэтому бизнес-требования должны учитывать окончательную согласованность между микрослужбами.
- В рабочей среде существует сложность при развертывании и управлении системой, скомпрометированной многими независимыми службами.
- Прямой обмен данными между клиентом и микрослужбой может усложнить рефакторинг контрактов микрослужб. Например, со временем секционирования системы по службам может потребоваться изменить. Одна служба может быть разбита на две или более служб, и две службы могут объединять их. Если клиенты обмениваются данными напрямую с микрослужбами, эта работа по рефакторингу может привести к нарушению совместимости с клиентскими приложениями.

## <a name="containerization"></a>Контейнеризация

Изоляция — это подход к разработке программного обеспечения, при котором приложение и его набор зависимостей, а также его конфигурация среды, абстрактные как файлы манифеста развертывания, упаковываются в виде образа контейнера, проверяются как единое целое и развертываются в операционной системе узла.

Контейнер — это изолированная, контролируемая и переносимая операционная среда, в которой приложение может работать, не затрагивая ресурсы других контейнеров или узла. Таким образом, контейнер выглядит и действует как недавно установленный физический компьютер или виртуальная машина.

Между контейнерами и виртуальными машинами существует много сходства, как показано на рисунке 8-3.

![Подход к масштабированию приложений микрослужб](containerized-microservices-images/containersvsvirtualmachines.png)

**Рис. 8-3**. Сравнение виртуальных машин и контейнеров

Контейнер работает под управлением операционной системы, имеет файловую систему и может быть доступен по сети, как если бы это был физический компьютер или виртуальная машина. Однако технология и понятия, используемые контейнерами, сильно отличаются от виртуальных машин. Виртуальные машины включают приложения, необходимые зависимости и полную операционную систему на виртуальной машине. Контейнеры включают приложение и его зависимости, но совместно используют операционную систему с другими контейнерами, выполняющимися как изолированные процессы в операционной системе узла (помимо контейнеров Hyper-V, которые выполняются внутри специальной виртуальной машины на контейнер). Таким образом, контейнеры совместно используют ресурсы и обычно требует меньше ресурсов, чем виртуальные машины.

Преимуществом подхода, ориентированного на разработку и развертывание в контейнере, является устранение большинства проблем, возникающих из-за несоответствия настроек среды и проблем, с которыми они поступают. Кроме того, контейнеры предоставляют возможность быстрого масштабирования приложений путем создания экземпляров новых контейнеров по мере необходимости.

Основные понятия при создании контейнеров и работе с ними:

- Узел контейнера: физическая или виртуальная машина, настроенная для размещения контейнеров. Узел контейнера будет запускать один или несколько контейнеров.
- Образ контейнера. образ состоит из объединения многоуровневых файловых систем, расположенных поверх других, и является основанием контейнера. Изображение не имеет состояния и не изменяется при развертывании в разных средах.
- Контейнер: контейнер — это экземпляр среды выполнения образа.
- Образ ОС контейнера. Контейнеры развертываются из образов. Образ операционной системы контейнера является первым слоем на потенциально многих слоях изображений, образующих контейнер. Операционная система контейнера является неизменяемой и не может быть изменена.
- Репозиторий контейнеров. каждый раз, когда создается образ контейнера, образ и его зависимости хранятся в локальном репозитории. Эти образы можно использовать повторно много раз на узле контейнера. Образы контейнеров также могут храниться в общедоступном или частном реестре, таком как [DOCKER Hub](https://hub.docker.com/), чтобы их можно было использовать на разных узлах контейнеров.

Предприятия все чаще внедряют контейнеры при реализации приложений на основе микрослужб, а DOCKER становится стандартной реализацией контейнера, которая реализована большинством платформ программного обеспечения и поставщиками облачных решений.

Приложение-образец eShopOnContainers использует DOCKER для размещения четырех контейнерных внутренних служб, как показано на рисунке 8-4.

![eShopOnContainers эталонные микрослужбы приложения](containerized-microservices-images/microservicesarchitecture.png)

**Рис. 8-4**. eShopOnContainers эталонные микрослужбы приложения

Архитектура серверных служб в эталонном приложении разбивается на несколько автономных подсистем в форме совместной работы микрослужб и контейнеров. Каждая микрослужба предоставляет единую область функциональных возможностей: службу идентификации, службу каталогов, службу заказов и службу корзины.

Каждая микрослужба имеет собственную базу данных, что позволяет полностью отменять ее связь с другими микрослужбами. При необходимости согласованность между базами данных из разных микрослужб достигается с помощью событий уровня приложения. Дополнительные сведения см. в разделе [Обмен данными между микрослужбами](#communication-between-microservices).

Дополнительные сведения о эталонном приложении см. в разделе [микрослужбы .NET — архитектура для контейнерных приложений .NET](https://aka.ms/microservicesebook).

## <a name="communication-between-client-and-microservices"></a>Обмен данными между клиентом и микрослужбами

Мобильное приложение eShopOnContainers взаимодействует с контейнерными внутренними микрослужбами с помощью прямого обмена данными между *клиентом* и микрослужбами, как показано на рис. 8-5.

![Подход к масштабированию приложений микрослужб](containerized-microservices-images/directclienttomicroservicecommunication.png)

**Рис. 8-5**. Прямая связь между клиентом и микрослужбой

С прямым обменом данными между клиентом и микрослужбами мобильное приложение выполняет запросы к каждой микрослужбе напрямую через общедоступную конечную точку с другим портом TCP на микрослужбу. В рабочей среде конечная точка обычно сопоставляется с подсистемой балансировки нагрузки микрослужбы, которая распределяет запросы по доступным экземплярам.

> [!TIP]
> Рассмотрите возможность использования взаимодействия с шлюзом API. Прямой обмен данными между клиентом и микрослужбой может иметь недостатки при создании большого и сложного приложения на основе микрослужб, но это более недостаточно для небольших приложений. При проектировании крупного приложения на основе микрослужб с десятками микрослужб рекомендуется использовать взаимодействие с шлюзом API. Дополнительные сведения см. в статье [.NET микрослужбы: архитектура для контейнерных приложений .NET](https://aka.ms/microservicesebook).

## <a name="communication-between-microservices"></a>Обмен данными между микрослужбами

Приложение на основе микрослужб — это распределенная система, которая может выполняться на нескольких компьютерах. Обычно каждый экземпляр службы — это процесс. Таким образом, службы должны взаимодействовать по протоколу межпроцессного взаимодействия, такому как HTTP, TCP, Расширенный протокол управления очередью сообщений (AMQP) или двоичные протоколы, в зависимости от природы каждой службы.

Два распространенных подхода к обмену данными между микрослужбами — это обмен данными на основе HTTP при запросе данных и упрощенный асинхронный обмен сообщениями при обмене обновлениями между несколькими микрослужбами.

Асинхронный обмен сообщениями на основе событий очень важен при распространении изменений в нескольких микрослужбах. При таком подходе микрослужба публикует событие, когда что-то получится, например при обновлении бизнес-сущности. Другие микрослужбы подписываются на эти события. Затем, когда микрослужба получает событие, оно обновляет собственные бизнес-сущности, которые, в свою очередь, могут привести к публикации дополнительных событий. Эта функция публикации и подписки обычно достигается с помощью шины событий.

Шина событий обеспечивает взаимодействие публикации и подписки между микрослужбами, не требуя от них явного уведомления друг от друга, как показано на рис. 8-6.

![Публикация и подписка с помощью шины событий](containerized-microservices-images/eventbus.png)

**Рис. 8-6.** Публикация и подписка с помощью шины событий

С точки зрения приложения, шина событий — это просто канал публикации и подписки, предоставляемый через интерфейс. Однако способ реализации шины событий может различаться. Например, реализация шины событий может использовать RabbitMQ, служебную шину Azure или другие служебные шины, такие как NServiceBus и MassTransit. На рис. 8-7 показано, как шина событий используется в эталонном приложении eShopOnContainers.

![Асинхронное взаимодействие на основе событий в приложении-образце](containerized-microservices-images/microservicesarchitecturewitheventbus.png)

**Рис. 8-7.** Асинхронное взаимодействие на основе событий в приложении-образце

Шина событий eShopOnContainers, реализованная с помощью RabbitMQ, предоставляет функции асинхронной публикации и подписки "один ко многим". Это означает, что после публикации события может быть несколько подписчиков, прослушивающих одно и то же событие. Эта связь показана на рис. 8-9.

![Связь «один ко многим»](containerized-microservices-images/eventdrivencommunication.png)

**Рис. 8-9**. связь «один ко многим»

Этот подход к обмену данными «один ко многим» использует события для реализации бизнес-транзакций, охватывающих несколько служб, обеспечивая окончательную согласованность между службами. Сквозная транзакция состоит из ряда распределенных шагов. Таким образом, когда микрослужба профиля пользователя получает команду Упдатеусер, она обновляет сведения о пользователе в своей базе данных и публикует событие Усерупдатед в шине событий. Микрослужба корзины и микрослужба заказа подписано на получение этого события, и в ответ на обновление сведений о покупателях в соответствующих базах данных.

> [!NOTE]
> Шина событий eShopOnContainers, реализованная с помощью RabbitMQ, предназначена для использования только в качестве подтверждения концепции. Для рабочих систем следует учитывать альтернативные реализации шины событий.

Сведения о реализации шины событий см. в разделе [микрослужбы .NET — архитектура для контейнерных приложений .NET](https://aka.ms/microservicesebook).

## <a name="summary"></a>Сводка

Микрослужбы предлагают подход к разработке и развертыванию приложений, который подходит для обеспечения гибкости, масштабирования и надежности современных облачных приложений. Одним из основных преимуществ микрослужб является то, что их можно масштабировать независимо друг от друга. Это означает, что можно масштабировать конкретную функциональную область, которая требует больше вычислительной мощности или пропускной способности сети для поддержки спроса, без необходимости масштабирования области приложения, не требующей увеличения спроса.

Контейнер — это изолированная, контролируемая и переносимая операционная среда, в которой приложение может работать, не затрагивая ресурсы других контейнеров или узла. Предприятия все чаще внедряют контейнеры при реализации приложений на основе микрослужб, а DOCKER становится стандартной реализацией контейнера, которая реализована большинством платформ программного обеспечения и поставщиками облачных решений.

## <a name="related-links"></a>Связанные ссылки

- [Скачать электронную книгу (2 МБ в формате PDF)](https://aka.ms/xamarinpatternsebook)
- [eShopOnContainers (GitHub) (пример)](https://github.com/dotnet-architecture/eShopOnContainers)
