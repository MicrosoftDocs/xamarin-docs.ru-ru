---
title: Взаимодействие между слабо связанными компонентами
description: 'В этой главе объясняется, как мобильное приложение eShopOnContainers реализует шаблон публикации и подписки, что позволяет осуществлять взаимодействие на основе сообщений между компонентами, которые неудобно связывать с ссылками на объекты и типы. '
ms.prod: xamarin
ms.assetid: 1194af33-8a91-48d2-88b5-b84d77f2ce69
ms.technology: xamarin-forms
author: davidbritch
ms.author: dabritch
ms.date: 08/07/2017
no-loc:
- Xamarin.Forms
- Xamarin.Essentials
ms.openlocfilehash: be8b0866a6d16fdec62f7c6cd3f4fc3e6de3168d
ms.sourcegitcommit: ebdc016b3ec0b06915170d0cbbd9e0e2469763b9
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/05/2020
ms.locfileid: "93374905"
---
# <a name="communicating-between-loosely-coupled-components"></a>Взаимодействие между слабо связанными компонентами

> [!NOTE]
> Эта электронная книга была опубликована в пружине 2017 и не была обновлена с этого момента. В книге есть много ценных материалов, но некоторые из них устарели.

Шаблон "публикация-подписка" — это шаблон обмена сообщениями, в котором издатели отправляют сообщение без знания о получателях, известных как подписчики. Аналогичным образом подписчики прослушивают определенные сообщения, не зная издателей.

События в .NET реализуют шаблон публикации и подписки, который представляет собой наиболее простой подход к обеспечению взаимодействия между компонентами, когда слабая связанность не требуется, как в случае с элементом управления и страницей, на которой он находится. Однако время существования издателя и время существования подписчика связаны посредством ссылок объектов друг на друга, и тип подписчика должен ссылаться на тип издателя. Из-за этого могут возникать проблемы с управлением памятью, особенно если существуют кратковременные объекты, которые подписаны на событие статического или долговременного объекта. Если обработчик событий не удаляется, подписчик продолжает существовать из-за ссылки на него в издателе, вследствие чего сборка мусора для подписчика будет отложена или не произойдет.

## <a name="introduction-to-messagingcenter"></a>Введение в Мессагингцентер

Класс [`MessagingCenter`](xref:Xamarin.Forms.MessagingCenter) в Xamarin.Forms реализует шаблон "публикация-подписка", который обеспечивает взаимодействие на основе сообщений между компонентами, которые неудобно связывать по ссылкам объектов и типов. Этот механизм позволяет издателям и подписчикам взаимодействовать без ссылки друг на друга, помогая сократить зависимости между компонентами, а также разрешать независимое разработку и тестирование компонентов.

Класс [`MessagingCenter`](xref:Xamarin.Forms.MessagingCenter) предоставляет функцию многоадресной публикации и подписки. Это означает, что может существовать несколько издателей, публикующих одно сообщение, и может быть несколько подписчиков, прослушивающих одно и то же сообщение. Эта связь показана на рис. 4-1:

![Функция многоадресной публикации и подписки](communicating-between-loosely-coupled-components-images/messagingcenter.png)

**Рис. 4-1.** Функция многоадресной публикации и подписки

Издатели отправляют сообщения с помощью метода [`MessagingCenter.Send`](xref:Xamarin.Forms.MessagingCenter.Send*), а подписчики прослушивают сообщения с помощью метода [`MessagingCenter.Subscribe`](xref:Xamarin.Forms.MessagingCenter.Subscribe*). Кроме того, подписчики могут также отменять подписку на сообщения, если это необходимо, с помощью метода [`MessagingCenter.Unsubscribe`](xref:Xamarin.Forms.MessagingCenter.Unsubscribe*).

На внутреннем уровне класс [`MessagingCenter`](xref:Xamarin.Forms.MessagingCenter) использует слабые ссылки. Это означает, что он не будет поддерживать объекты в активном состоянии и позволит им собирать мусор. Поэтому необходимо отменять подписку на сообщения только в том случае, если классу больше не требуется получать сообщения.

Мобильное приложение eShopOnContainers использует [`MessagingCenter`](xref:Xamarin.Forms.MessagingCenter) класс для обмена данными между слабо связанными компонентами. Приложение определяет три сообщения:

- `AddProduct`Сообщение публикуется `CatalogViewModel` классом при добавлении элемента в корзину покупок. В случае возврата `BasketViewModel` класс подписывается на сообщение и увеличивает количество элементов в корзине покупок в ответе. Кроме того, класс также отменяет `BasketViewModel` Подписывание этого сообщения.
- `Filter`Сообщение публикуется `CatalogViewModel` классом, когда пользователь применяет торговую марку или фильтр типа к элементам, отображаемым в каталоге. В случае возврата `CatalogView` класс подписывается на сообщение и обновляет пользовательский интерфейс, чтобы отображались только те элементы, которые соответствуют условиям фильтра.
- `ChangeTab`Сообщение публикуется `MainViewModel` классом при `CheckoutViewModel` переходе к `MainViewModel` следующему успешному созданию и отправке нового заказа. В случае возврата `MainView` класс подписывается на сообщение и обновляет пользовательский интерфейс, чтобы вкладка **Мой профиль** была активной, чтобы отображались заказы пользователя.

> [!NOTE]
> Хотя [`MessagingCenter`](xref:Xamarin.Forms.MessagingCenter) класс допускает обмен данными между слабо связанными классами, он не предоставляет единственно архитектурное решение для этой проблемы. Например, взаимодействие между моделью представления и представлением также может быть достигнуто подсистемой привязки и уведомлениями об изменении свойств. Кроме того, связь между двумя моделями представления также может быть достигнута путем передачи данных во время навигации.

В мобильном приложении eShopOnContainers [`MessagingCenter`](xref:Xamarin.Forms.MessagingCenter) используется для обновления в пользовательском интерфейсе в ответ на действие, происходящее в другом классе. Поэтому сообщения публикуются в потоке пользовательского интерфейса, при этом подписчики получают сообщение в том же потоке.

> [!TIP]
> Выполнить упаковку в поток пользовательского интерфейса при выполнении обновлений пользовательского интерфейса. Если сообщение, отправленное из фонового потока, требуется для обновления пользовательского интерфейса, обработайте сообщение в потоке пользовательского интерфейса на подписчике, вызвав [`Device.BeginInvokeOnMainThread`](xref:Xamarin.Forms.Device.BeginInvokeOnMainThread(System.Action)) метод.

Дополнительные сведения о [`MessagingCenter`](xref:Xamarin.Forms.MessagingCenter) см. в разделе [мессагингцентер](~/xamarin-forms/app-fundamentals/messaging-center.md).

## <a name="defining-a-message"></a>Определение сообщения

[`MessagingCenter`](xref:Xamarin.Forms.MessagingCenter) сообщения — это строки, используемые для распознавания сообщений. В следующем примере кода показаны сообщения, определенные в мобильном приложении eShopOnContainers:

```csharp
public class MessageKeys  
{  
    // Add product to basket  
    public const string AddProduct = "AddProduct";  

    // Filter  
    public const string Filter = "Filter";  

    // Change selected Tab programmatically  
    public const string ChangeTab = "ChangeTab";  
}
```

В этом примере сообщения определяются с помощью констант. Преимущество такого подхода заключается в том, что он обеспечивает безопасность типов во время компиляции и поддержку рефакторинга.

## <a name="publishing-a-message"></a>Публикация сообщения

Издатели уведомляют подписчиков о сообщении с помощью одной из перегрузок [`MessagingCenter.Send`](xref:Xamarin.Forms.MessagingCenter.Send*). В следующем примере кода демонстрируется публикация `AddProduct` сообщения.

```csharp
MessagingCenter.Send(this, MessageKeys.AddProduct, catalogItem);
```

В этом примере [`Send`](xref:Xamarin.Forms.MessagingCenter.Send*) метод задает три аргумента:

- Первый аргумент указывает класс отправителя. Класс Sender должен быть указан любым подписчикам, желающим получить сообщение.
- Второй аргумент указывает само сообщение.
- Третий аргумент указывает полезные данные, которые будут отправлены подписчику. В этом случае полезные данные являются `CatalogItem` экземпляром.

[`Send`](xref:Xamarin.Forms.MessagingCenter.Send*)Метод опубликует сообщение и его полезные данные с помощью метода пожара и-забыть. Поэтому сообщение отправляется, даже если отсутствуют подписчики, зарегистрированные для получения сообщения. В этом случае отправленное сообщение игнорируется.

> [!NOTE]
> [`MessagingCenter.Send`](xref:Xamarin.Forms.MessagingCenter.Send*)Метод может использовать универсальные параметры для управления доставкой сообщений. Таким образом, разные подписчики могут получать несколько сообщений с общим удостоверением, но отправлять различные типы полезных данных.

## <a name="subscribing-to-a-message"></a>Подписка на сообщение

Подписчики могут зарегистрироваться для получения сообщения с помощью одной из перегрузок [`MessagingCenter.Subscribe`](xref:Xamarin.Forms.MessagingCenter.Subscribe*). В следующем примере кода показано, как мобильное приложение eShopOnContainers подписывается на, и обрабатывает `AddProduct` сообщение:

```csharp
MessagingCenter.Subscribe<CatalogViewModel, CatalogItem>(  
    this, MessageKeys.AddProduct, async (sender, arg) =>  
{  
    BadgeCount++;  

    await AddCatalogItemAsync(arg);  
});
```

В этом примере [`Subscribe`](xref:Xamarin.Forms.MessagingCenter.Subscribe*) метод подписывается на `AddProduct` сообщение и выполняет делегат обратного вызова в ответ на получение сообщения. Этот делегат обратного вызова, указанный в лямбда-выражении, выполняет код, который обновляет пользовательский интерфейс.

> [!TIP]
> Рассмотрите возможность использования неизменяемых полезных данных. Не пытайтесь изменить полезные данные из делегата обратного вызова, так как несколько потоков могут одновременно получить доступ к полученным данным. В этом сценарии полезные данные должны быть неизменными, чтобы избежать ошибок параллелизма.

Подписчику может не потребоваться обрабатывать каждый экземпляр опубликованного сообщения, и это можно контролировать с помощью аргументов универсального типа, указанных в методе [`Subscribe`](xref:Xamarin.Forms.MessagingCenter.Subscribe*). В этом примере подписчик будет принимать только `AddProduct` сообщения, отправленные из `CatalogViewModel` класса, полезные данные которого являются `CatalogItem` экземпляром.

## <a name="unsubscribing-from-a-message"></a>Отмена подписки на сообщение

Если подписчики больше не должны получать сообщения, можно отменить подписку на них. Это достигается с одной из [`MessagingCenter.Unsubscribe`](xref:Xamarin.Forms.MessagingCenter.Unsubscribe*) перегрузок, как показано в следующем примере кода:

```csharp
MessagingCenter.Unsubscribe<CatalogViewModel, CatalogItem>(this, MessageKeys.AddProduct);
```

В этом примере [`Unsubscribe`](xref:Xamarin.Forms.MessagingCenter.Unsubscribe*) синтаксис метода отражает аргументы типа, указанные при подписке на получение `AddProduct` сообщения.

## <a name="summary"></a>Сводка

Класс [`MessagingCenter`](xref:Xamarin.Forms.MessagingCenter) в Xamarin.Forms реализует шаблон "публикация-подписка", который обеспечивает взаимодействие на основе сообщений между компонентами, которые неудобно связывать по ссылкам объектов и типов. Этот механизм позволяет издателям и подписчикам взаимодействовать без ссылки друг на друга, помогая сократить зависимости между компонентами, а также разрешать независимое разработку и тестирование компонентов.

## <a name="related-links"></a>Связанные ссылки

- [Скачать электронную книгу (2 МБ в формате PDF)](https://aka.ms/xamarinpatternsebook)
- [eShopOnContainers (GitHub) (пример)](https://github.com/dotnet-architecture/eShopOnContainers)
