---
ms.assetid: 7C132A7C-4973-4B2D-98DC-3661C08EA33F
title: Жизненный цикл приложения WPF и Xamarin. Forms
description: В этом документе сравниваются сходства и различия между жизненным циклом приложения для Xamarin. Forms и приложений WPF. Он также рассматривает визуальное дерево, графику, ресурсы и стили.
author: davidortinau
ms.author: daortin
ms.date: 04/26/2017
ms.openlocfilehash: 6e959156aada0451efa13f6b67b6637f4e5deaa5
ms.sourcegitcommit: 836d54779190b1bef1b43bc0c2016c9b3034bfda
ms.translationtype: MT
ms.contentlocale: ru-RU
ms.lasthandoff: 11/03/2020
ms.locfileid: "93281239"
---
# <a name="wpf-vs-xamarinforms-app-lifecycle"></a>Жизненный цикл приложения WPF и Xamarin. Forms

Xamarin. Forms принимает множество руководств по проектированию из платформ на основе XAML, которые были выпущены до этого, особенно в WPF. Тем не менее, в других случаях это сильно отличается от того, что может быть закрепления для пользователей, пытающихся выполнить миграцию. В этом документе предпринимается попытка найти некоторые из этих проблем и предоставлены рекомендации по взаимовозможности моста данных WPF в Xamarin. Forms.

## <a name="app-lifecycle"></a>Жизненный цикл приложения

Жизненный цикл приложения между WPF и Xamarin. Forms аналогичен. Оба запускаются во внешнем коде (на платформе) и запускают пользовательский интерфейс с помощью вызова метода. Отличие заключается в том, что Xamarin. Forms всегда начинается в сборке, зависящей от платформы, которая затем инициализирует и создает пользовательский интерфейс для приложения.

**WPF**

- `Main method > App > MainWindow`

> [!NOTE]
> По `Main` умолчанию этот метод создается автоматически и не отображается в коде.

**Xamarin.Forms**

- **iOS** &ndash; `Main method > AppDelegate > App > ContentPage`
- **Android** &ndash;`MainActivity > App > ContentPage`
- **UWP** &ndash;`Main method > App(UWP) > MainPage(UWP) > App > ContentPage`

### <a name="application-class"></a>Класс приложений

Как WPF, так и Xamarin. Forms имеют `Application` класс, который создается как одноэлементный. В большинстве случаев приложения будут производными от этого класса для предоставления пользовательского приложения, хотя это не является обязательным в WPF. Оба предоставляют `Application.Current` свойство для размещения созданного одноэлементного экземпляра.

### <a name="global-properties--persistence"></a>Глобальные свойства и сохраняемость

Как WPF, так и Xamarin. Forms `Application.Properties` доступны по словарю, где можно хранить глобальные объекты уровня приложения, доступные в любом месте приложения. Ключевое различие заключается в том, что Xamarin. Forms _сохранит все типы_ -примитивы, хранящиеся в коллекции, когда приложение будет приостановлено, и перезагрузить их при повторном запуске. WPF не поддерживает такое поведение автоматически. вместо этого большинство разработчиков полагаться на изолированное хранилище или использует встроенную `Settings` поддержку.

## <a name="defining-pages-and-the-visual-tree"></a>Определение страниц и визуального дерева

WPF использует в `Window` качестве корневого элемента для любого визуального элемента верхнего уровня. Это определяет HWND в мире Windows для вывода сведений. В WPF можно создавать и отображать любое количество окон одновременно.

В Xamarin. Forms визуальный элемент верхнего уровня всегда определяется платформой, например в iOS `UIWindow` . Xamarin. Forms преобразует содержимое в эти собственные представления платформы с помощью `Page` класса. Каждый `Page` в Xamarin. Forms представляет собой уникальную "страницу" в приложении, где только одна видима за раз.

Как Впфс `Window` , так и Xamarin. Forms `Page` включают `Title` свойство, влияющее на отображаемое название, и оба имеют `Icon` свойство для отображения определенного значка для страницы ( **Обратите внимание** , что заголовок и значок не всегда видны в Xamarin. Forms). Кроме того, можно изменять общие визуальные свойства как для фона, так и для изображения.

Технически можно выполнить визуализацию в двух отдельных представлениях платформы (например, определить два `UIWindow` объекта и получить вторую визуализацию на внешний экран или AirPlay), для этого требуется код, зависящий от платформы, и не является непосредственно поддерживаемой функцией Xamarin. Forms.

### <a name="views"></a>Представления

Визуальная иерархия для обеих платформ аналогична. WPF является несколько более глубоким из-за поддержки документов WYSIWYG.

**WPF**

```
DependencyObject - base class for all bindable things
   Visual - rendering mechanics
      UIElement - common events + interactions
         FrameworkElement - adds layout
            Shape - 2D graphics
            Control - interactive controls
```

**Xamarin.Forms**

```
BindableObject - base class for all bindable things
   Element - basic parent/child support + resources + effects
      VisualElement - adds visual rendering properties (color, fonts, transforms, etc.)
         View - layout + gesture support
```

### <a name="view-lifecycle"></a>Жизненный цикл представления

Xamarin. Forms в основном ориентированы на мобильные сценарии. Таким образом, приложения _активируются_ , _приостанавливаются_ и _повторно активируются_ по мере взаимодействия пользователя с ними. Это похоже на щелчок `Window` в приложении WPF, и существует набор методов и соответствующих событий, которые можно переопределить или подключить для отслеживания этого поведения.

| Назначение | Метод WPF | Метод Xamarin. Forms |
|--- |--- |--- |
|Начальная активация|ctor + окно. onloadо|ctor + Page. OnStart|
|Указанного|Window. Исвисиблечанжед|Страница. появляется|
|Скрытый|Window. Исвисиблечанжед|Страница. отображается|
|Фокус приостановки или потери|Окно. OnDeactivate|Страница. Переход в спящий режим|
|Активированный/полученный фокус|Окно. onactivateось|Страница. onresume|
|Закрыто|Window. OnClosing + Window. onclosingось|Н/Д|

Обе поддерживают скрытие и отображение дочерних элементов управления. в WPF это свойство с тремя состояниями `IsVisible` (видимое, скрытое и свернутое). В Xamarin. Forms он просто видим или скрыт с помощью `IsVisible` Свойства.

### <a name="layout"></a>Layout

Макет страницы выполняется в одном 2-проходном (измерении или упорядочении) в WPF. Можно присоединиться к макету страницы, переопределив следующие методы в классе Xamarin. Forms `Page` :

| Метод | Назначение |
|--- |--- |
|ончилдмеасуреинвалидатед|Предпочтительный размер дочернего элемента изменился.|
|онсизеаллокатед|Странице была назначена ширина и высота.|
|Событие Лайаутчанжед|Изменился макет или размер страницы.|

Не существует события глобального макета, которое вызывается сегодня, и в WPF не существует глобального `CompositionTarget.Rendering` события, такого как Found.

#### <a name="common-layout-properties"></a>Общие свойства макета

WPF и Xamarin. Forms поддерживают `Margin` Управление пространством вокруг элемента и `Padding` управляют пространством _внутри_ элемента. Кроме того, большинство представлений макета Xamarin. Forms имеют свойства для управления пространством (например, строка или столбец).

Кроме того, большинство элементов имеют свойства, которые влияют на то, как они расположены в родительском контейнере:

| WPF | Xamarin.Forms | Назначение |
|--- |--- |--- |
|HorizontalAlignment|хоризонталоптионс|Параметры Left, Center, Right/Stretch|
|VerticalAlignment|вертикалоптионс|Параметры Top, Center, Bottom/Stretch|

> [!NOTE]
> Фактическая интерпретация этих свойств зависит от родительского контейнера.

#### <a name="layout-views"></a>Представления макета

WPF и Xamarin. Forms используют элементы управления макета для размещения дочерних элементов. В большинстве случаев они очень близки друг к другу с точки зрения функциональности.

| WPF | Xamarin.Forms | Стиль макета |
|--- |--- |--- |
|StackPanel|StackLayout|Бесконечные стеки с направлением слева направо или сверху вниз|
|Макет Grid|Макет Grid|Табличный формат (строки и столбцы)|
|DockPanel|Н/Д|Закрепить на краях окна|
|Холст|AbsoluteLayout|Пиксельное и координатное позиционирование|
|WrapPanel|Н/Д|Стек переноса|
|Н/Д|RelativeLayout|Относительное позиционирование на основе правил|

> [!NOTE]
> Xamarin. Forms не поддерживает `GridSplitter` .

В обеих платформах _присоединенные свойства_ используются для точной настройки дочерних элементов.

### <a name="rendering"></a>Отрисовка

Механизм визуализации для WPF и Xamarin. Forms имеет коренные отличия. В WPF элементы управления, создаваемые непосредственно, отображают содержимое в пикселах на экране. WPF поддерживает два графа объектов ( _деревьев_ ) для представления этого — _логическое дерево_ представляет элементы управления, как определено в коде или коде XAML, а _визуальное дерево_ — фактическую отрисовку, выполняемую на экране, которая выполняется либо непосредственно визуальным элементом (посредством метода Draw), либо с помощью определяемого XAML, `ControlTemplate` который можно заменить или настроить. Как правило, визуальное дерево сложнее, так как оно включает границы вокруг элементов управления, метки для неявного содержимого и т. д. В состав WPF входит набор API-интерфейсов ( `LogicalTreeHelper` и `VisualTreeHelper` ) для изучения этих двух графов объектов.

В Xamarin. Forms элементы управления, определяемые в, `Page` — это просто простые объекты данных. Они похожи на представление логического дерева, но никогда не отображают содержимое самостоятельно. Вместо этого они являются _моделью данных_ , которая влияет на отрисовку элементов. Фактическая визуализация выполняется [отдельным набором _визуальных модулей подготовки_ отчетов, которые сопоставляются с каждым типом элемента управления](~/xamarin-forms/app-fundamentals/custom-renderer/index.md). Эти модули подготовки регистрируются в каждом из проектов для конкретной платформы с помощью сборок Xamarin. Forms, зависящих от платформы. Список можно просмотреть [здесь](~/xamarin-forms/app-fundamentals/custom-renderer/renderers.md). Помимо замены или расширения модуля подготовки отчетов, Xamarin. Forms также поддерживает [эффекты](~/xamarin-forms/app-fundamentals/effects/index.md) , которые можно использовать для повлиять на отрисовку в собственном режиме на уровне платформы.

#### <a name="the-logicalvisual-tree"></a>Логическое или визуальное дерево

Нет доступного API для прохода по логическому дереву в Xamarin. Forms, но можно использовать отражение для получения той же информации. Например, [ниже приведен метод, который может перечислять логические дочерние элементы](https://github.com/xamarinhq/xamu-infrastructure/blob/master/src/XamU.Infrastructure/Extensions/ElementExtensions.cs#L108) с помощью отражения.

## <a name="graphics"></a>Графика

Xamarin. Forms включает графическую систему для рисования примитивов, которые называются фигурами. Дополнительные сведения о фигурах см. в разделе [фигуры Xamarin. Forms](~/xamarin-forms/user-interface/shapes/index.md). Кроме того, можно включить сторонние библиотеки, такие как [SkiaSharp](~/xamarin-forms/user-interface/graphics/index.md) , для получения 2D-рисования на разных платформах.

## <a name="resources"></a>Ресурсы

WPF и Xamarin. Forms имеют концепцию ресурсов и словарей ресурсов. Любой тип объекта можно поместить в `ResourceDictionary` ключ с ключом, а затем выполнить поиск `{StaticResource}` для тех вещей, которые не изменяются, а также `{DynamicResource}` для объектов, которые могут изменяться в словаре во время выполнения. Использование и механика одинаковы, и одно из различий: Xamarin. Forms требует, чтобы вы определили, что нужно `ResourceDictionary` назначить `Resources` свойству, тогда как WPF предсоздаст его и присвоит ему.

Например, см. определение ниже:

**WPF**

```xaml
<Window.Resources>
   <Color x:Key="redColor">#ff0000</Color>
   ...
</Window.Resources>
```

**Xamarin.Forms**

```xaml
<ContentPage.Resources>
   <ResourceDictionary>
      <Color x:Key="redColor">#ff0000</Color>
      ...
   </ResourceDictionary>
</ContentPage.Resources>
```

Если не определить `ResourceDictionary` , возникает ошибка времени выполнения.

## <a name="styles"></a>стили.

Стили также полностью поддерживаются в Xamarin. Forms и могут использоваться для создания темы для элементов Xamarin. Forms, составляющих пользовательский интерфейс. Они поддерживают триггеры (свойство, событие и данные), наследование `BasedOn` и поиск ресурсов для значений. Стили применяются к элементам явным образом через `Style` свойство или неявно, не указывая ключ ресурса — так же, как WPF.

### <a name="device-styles"></a>Стили устройства

WPF имеет набор предопределенных свойств (хранимых как статические значения для набора статических классов, таких как `SystemColors` ), которые определяют системные цвета, шрифты и метрики в форме значений и ключей ресурсов. Xamarin. Forms аналогичен, но определяет набор [стилей устройств](~/xamarin-forms/user-interface/styles/device.md) для представления тех же вещей. Эти стили предоставляются платформой и устанавливаются в значения, основанные на среде выполнения (например, Специальные возможности).

**WPF**

```xaml
<Label Text="Title" Foreground="{DynamicResource {x:Static SystemColors.DesktopBrushKey}}" />
```

**Xamarin.Forms**

```xaml
<Label Text="Title" Style="{DynamicResource TitleStyle}" />
```
